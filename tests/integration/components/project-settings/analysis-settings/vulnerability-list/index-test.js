import { click, fillIn, findAll, render } from '@ember/test-helpers';
import { hbs } from 'ember-cli-htmlbars';
import { setupMirage } from 'ember-cli-mirage/test-support';
import { setupIntl, t } from 'ember-intl/test-support';
import { setupRenderingTest } from 'ember-qunit';
import { module, test } from 'qunit';
import Service from '@ember/service';
import { selectChoose } from 'ember-power-select/test-support';
import { isEmpty } from '@ember/utils';

import ENUMS from 'irene/enums';
import akSelectStyles from 'irene/components/ak-select/index.scss';
import { analysisRiskStatus } from 'irene/helpers/analysis-risk-status';
import { riskText } from 'irene/helpers/risk-text';
import { getReqBodyObjFromReqBodyStr } from 'irene/tests/helpers/mirage-utils';

// General Selectors for common elements
const GENERAL_SELECTORS = {
  riskTag:
    '[data-test-prjSettings-analysisSettings-vulnPreferenceItem-riskTag]',
  actionBtn:
    '[data-test-prjSettings-analysisSettings-vulnPreferenceItem-action]',
  overridenIcon:
    '[data-test-prjSettings-analysisSettings-vulnPreferenceItem-actionOverridenIcon]',
  editIcon:
    '[data-test-prjSettings-analysisSettings-vulnPreferenceItem-actionEditIcon]',
  vulnPrefRowItem:
    '[data-test-prjSettings-analysisSettings-vulnPreference-list-row]',
  vulnPrefName:
    '[data-test-prjSettings-analysisSettings-vulnPreferenceItem-name]',

  // Drawer Override Form/Details Selectors
  overrideEditDrawerTitle: '[data-test-analysisRisk-overrideEditDrawer-title]',
  overrideEditDrawerDivider:
    '[data-test-analysisRisk-overrideEditDrawer-divider]',
  overrideEditDrawerCloseBtn:
    '[data-test-analysisRisk-overrideEditDrawer-closeBtn]',
  OEFVulnerabilityRiskTag:
    '[data-test-analysisRisk-overrideEditDrawer-vulnerabilityRiskTag]',
  OEFVulnerabilityName:
    '[data-test-analysisRisk-overrideEditDrawer-vulnerabilityName]',
  OEFVulnerabilityNameLabel:
    '[data-test-analysisRisk-overrideEditDrawer-vulnerabilityNameLabel]',
  OEFOverrideLabelText:
    '[data-test-analysisRisk-overrideEditDrawer-overrideForm-overrideToLabel]',
  OEFOverrideToSelect:
    '[data-test-analysisRisk-overrideEditDrawer-overrideForm-overrideToSelect]',
  OEFOverrideCriteriaText:
    '[data-test-analysisRisk-overrideEditDrawer-overrideForm-overrideCriteriaText]',
  OEFCommentLabel:
    '[data-test-analysisRisk-overrideEditDrawer-overrideForm-commentLabel]',
  OEFCommentInput:
    '[data-test-analysisRisk-overrideEditDrawer-overrideForm-commentInput]',
  OEFSaveBtn:
    '[data-test-analysisRisk-overrideEditDrawer-overrideForm-saveBtn]',
  OEFCancelBtn:
    '[data-test-analysisRisk-overrideEditDrawer-overrideForm-cancelBtn]',
  OEFResetBtn:
    '[data-test-analysisRisk-overrideEditDrawer-overrideDetails-resetBtn]',
  OEFEditBtn:
    '[data-test-analysisRisk-overrideEditDrawer-overrideDetails-editBtn]',
  OEFSuccessSvg:
    '[data-test-analysisRisk-overrideEditDrawer-overrideForm-successSvg]',
  OEFSuccessMsg:
    '[data-test-analysisRisk-overrideEditDrawer-overrideForm-successMsg]',
  OEFOverrideSelectHelperText:
    '[data-test-analysisRisk-overrideEditDrawer-overrideForm-overrideSelectHelperText]',
  OEFRiskCriteriaSelectErrorText:
    '[data-test-analysisRisk-overrideEditDrawer-overrideForm-riskCriteriaSelectError]',
  OEFCommentInputErrorText:
    '[data-test-analysisRisk-overrideEditDrawer-overrideForm-commentInputError]',
  OEFReasonTitle:
    '[data-test-analysisRisk-overrideEditDrawer-overrideDetails-reasonTitle]',
  OEFReasonValue:
    '[data-test-analysisRisk-overrideEditDrawer-overrideDetails-reasonValue]',
};

// Create Selector values for "overrideDetails" drawer
const OVERIDED_DETAILS_SELECTORS = Object.keys(GENERAL_SELECTORS).reduce(
  (prevVal, s) => ({
    ...prevVal,
    ...(GENERAL_SELECTORS[s].includes('overrideForm')
      ? { [s]: GENERAL_SELECTORS[s].replace('overrideForm', 'overrideDetails') }
      : { [s]: GENERAL_SELECTORS[s] }),
  }),
  {}
);

// Risk override select element classes
const OEFOverrideToSelectClasses = {
  dropdown: akSelectStyles['ak-select-dropdown'],
  trigger: akSelectStyles['ak-select-trigger'],
};

// Overidden Risk choices
const OVERRIDE_RISKS_CHOICES = ENUMS.RISK.CHOICES.filter(
  (risk) => ![ENUMS.RISK.UNKNOWN].includes(risk.value)
).sort((a, b) => b.value - a.value);

const getAnalysisRiskText = (risk) =>
  analysisRiskStatus([risk, ENUMS.ANALYSIS.COMPLETED, true]).label;

// Sanity check for override/edit drawer
const checkOverrideEditDrawerDetails = (
  assert,
  vulnPref,
  relatedVulnerability
) => {
  const isAlreadyEdited = !isEmpty(vulnPref.risk);

  const ELEMENT_SELECTORS = isAlreadyEdited
    ? OVERIDED_DETAILS_SELECTORS
    : GENERAL_SELECTORS;

  assert
    .dom(GENERAL_SELECTORS.overrideEditDrawerTitle)
    .exists()
    .hasText(isAlreadyEdited ? t('overrideDetails') : t('editAnalysis'));

  assert.dom(ELEMENT_SELECTORS.overrideEditDrawerCloseBtn).exists();

  assert
    .dom(ELEMENT_SELECTORS.OEFVulnerabilityNameLabel)
    .exists()
    .hasText(t('editOverrideVulnerability.nameOfTheVulnerability'));

  assert
    .dom(ELEMENT_SELECTORS.OEFVulnerabilityName)
    .exists()
    .hasText(relatedVulnerability.name);

  const riskTagOverrideIconSelector = `${ELEMENT_SELECTORS.OEFVulnerabilityRiskTag} [data-test-analysisRiskTag-editIcon]`;
  const riskTagOverrideTextSelector = `${ELEMENT_SELECTORS.OEFVulnerabilityRiskTag} [data-test-analysisRiskTag-label]`;

  if (vulnPref.risk !== null) {
    assert
      .dom(riskTagOverrideTextSelector)
      .containsText(getAnalysisRiskText(vulnPref.risk));
  }

  if (isAlreadyEdited) {
    assert.dom(riskTagOverrideIconSelector).exists();

    assert
      .dom(ELEMENT_SELECTORS.OEFReasonTitle)
      .exists()
      .containsText(t('reason'));

    assert
      .dom(ELEMENT_SELECTORS.OEFReasonValue)
      .exists()
      .hasText(vulnPref.comment);

    assert
      .dom(ELEMENT_SELECTORS.OEFResetBtn)
      .exists()
      .hasText(t('resetOverride'));

    assert.dom(ELEMENT_SELECTORS.OEFEditBtn).exists().hasText(t('edit'));
  } else {
    assert.dom(riskTagOverrideIconSelector).doesNotExist();
    assert.dom(ELEMENT_SELECTORS.OEFCancelBtn).exists().hasText(t('cancel'));
    assert.dom(ELEMENT_SELECTORS.OEFSaveBtn).exists().hasText(t('save'));
  }

  assert
    .dom(
      ELEMENT_SELECTORS.OEFOverrideLabelText.replace(
        isAlreadyEdited ? 'overrideToLabel' : '',
        isAlreadyEdited ? 'overriddenAsTitle' : ''
      )
    )
    .exists();
};

// Service stubs
class NotificationsStub extends Service {
  errorMsg = null;
  successMsg = null;

  error(msg) {
    this.errorMsg = msg;
    return this.errorMsg;
  }

  success(msg) {
    this.successMsg = msg;
    return this.successMsg;
  }
}

class OrganizationMeStub extends Service {
  org = {
    is_owner: true,
    is_admin: true,
  };
}

// Test Body
module(
  'Integration | Component | project-settings/analysis-settings/vulnerability-list',
  function (hooks) {
    setupRenderingTest(hooks);
    setupMirage(hooks);
    setupIntl(hooks);

    hooks.beforeEach(async function () {
      // Server Mocks
      this.server.get('/profiles/:id/vulnerability_preferences', (schema) => {
        return schema['vulnerabilityPreferences'].all().models;
      });

      // Service stubs
      this.owner.register('service:me', OrganizationMeStub);
      this.owner.register('service:notifications', NotificationsStub);

      this.notifyService = this.owner.lookup('service:notifications');

      await this.owner.lookup('service:organization').load();

      const store = this.owner.lookup('service:store');

      // Common test variables
      this.server.create('organization', 1);
      const profile = this.server.create('profile');

      const project = this.server.create('project', {
        activeProfileId: profile.id,
      });

      const createRelatedVulnerability = (vulnPref) => {
        const relatedVulnerability = this.server.create('vulnerability', {
          id: vulnPref.id,
        });

        this.store.push(
          this.store.normalize('vulnerability', {
            attributes: relatedVulnerability.toJSON(),
            id: vulnPref.id,
            type: 'vulnerability',
          })
        );

        return relatedVulnerability;
      };

      this.setProperties({
        createRelatedVulnerability,
        project,
        store,
      });
    });

    test('it does not render when user is not admin', async function (assert) {
      class OrganizationMeStub extends Service {
        org = {
          is_owner: true,
          is_admin: false,
        };
      }

      this.owner.register('service:me', OrganizationMeStub);

      await render(
        hbs`<ProjectSettings::AnalysisSettings::VulnerabilityList @project={{this.project}} />`
      );

      assert.dom('[data-test-vulnerability-list-container]').doesNotExist();
    });

    test('it renders when user is admin', async function (assert) {
      await render(
        hbs`<ProjectSettings::AnalysisSettings::VulnerabilityList @project={{this.project}} />`
      );

      assert.dom('[data-test-vulnerability-list-container]').exists();

      assert
        .dom('[data-test-vulnerability-list-header-text]')
        .hasText(t('vulnerabilityPreferences'));

      assert
        .dom('[data-test-vulnerability-list-warning-pref-conditions]')
        .hasTextContaining(t('warning'))
        .hasTextContaining(t('vulnerabilityPreferencesCondition'));

      assert
        .dom('[data-test-prjSettings-analysisSettings-vulnPreference-list]')
        .containsText(t('vulnerability'))
        .containsText(t('editOverrideVulnerability.overriddenSeverity'))
        .containsText(t('action'));
    });

    test('it renders an unedited vulnerability in vulnerability preference list', async function (assert) {
      const vulnPref = this.server.create('vulnerability-preference', {
        risk: null,
      });

      const relatedVulnerability = this.createRelatedVulnerability(vulnPref);

      await render(
        hbs`<ProjectSettings::AnalysisSettings::VulnerabilityList @project={{this.project}} />`
      );

      assert.dom('[data-test-vulnerability-list-container]').exists();

      assert
        .dom('[data-test-vulnerability-list-header-text]')
        .hasText(t('vulnerabilityPreferences'));

      const numberOfVulnerabilityItems = this.element.querySelectorAll(
        GENERAL_SELECTORS.vulnPrefRowItem
      );

      assert.strictEqual(
        numberOfVulnerabilityItems.length,
        1,
        'Renders the correct number of vulnerability items'
      );

      // Sanity check for vulnerability details

      assert
        .dom(GENERAL_SELECTORS.vulnPrefName, numberOfVulnerabilityItems[0])
        .exists()
        .hasText(relatedVulnerability.name);

      assert
        .dom(GENERAL_SELECTORS.editIcon, numberOfVulnerabilityItems[0])
        .exists()
        .hasClass(/ak-icon-edit/);

      assert
        .dom(GENERAL_SELECTORS.riskTag, numberOfVulnerabilityItems[0])
        .doesNotExist();
    });

    test('it renders edited risk value and icon if vulnerability preference risk is edited', async function (assert) {
      const vulnPref = this.server.create('vulnerability-preference', {
        risk: 1,
      });

      const relatedVulnerability = this.createRelatedVulnerability(vulnPref);

      await render(
        hbs`<ProjectSettings::AnalysisSettings::VulnerabilityList @project={{this.project}} />`
      );

      assert.dom('[data-test-vulnerability-list-container]').exists();

      assert
        .dom('[data-test-vulnerability-list-header-text]')
        .hasText(t('vulnerabilityPreferences'));

      const numberOfVulnerabilityItems = this.element.querySelectorAll(
        GENERAL_SELECTORS.vulnPrefRowItem
      );

      assert
        .dom(GENERAL_SELECTORS.vulnPrefName, numberOfVulnerabilityItems[0])
        .exists()
        .hasText(relatedVulnerability.name);

      assert
        .dom(GENERAL_SELECTORS.overridenIcon, numberOfVulnerabilityItems[0])
        .exists();

      assert
        .dom(GENERAL_SELECTORS.riskTag, numberOfVulnerabilityItems[0])
        .exists()
        .containsText(getAnalysisRiskText(vulnPref.risk));

      assert
        .dom(
          `${GENERAL_SELECTORS.riskTag} [data-test-analysisRiskTag-editIcon]`,
          numberOfVulnerabilityItems[0]
        )
        .exists();
    });

    test.each(
      'it edits a vulnerability preference',
      [
        // No Risk -> Risk
        {
          risk: null,
          riskToEditTo: ENUMS.RISK.CRITICAL,
          expected: 42,
        },
        // Risk -> Passed
        {
          risk: ENUMS.RISK.CRITICAL,
          riskToEditTo: ENUMS.RISK.NONE,
          expected: 43,
        },
        // Risk -> Risk
        {
          risk: ENUMS.RISK.HIGH,
          riskToEditTo: ENUMS.RISK.LOW,
          expected: 41,
        },
        // Passed -> Risk
        {
          risk: ENUMS.RISK.NONE,
          riskToEditTo: ENUMS.RISK.CRITICAL,
          expected: 41,
        },
      ],
      async function (assert, { risk, riskToEditTo, expected }) {
        assert.expect(expected);

        // Server Mocks
        this.server.get('/profiles/:id/vulnerability_preferences', (schema) => {
          return schema['vulnerabilityPreferences'].all().models;
        });

        this.server.put(
          '/profiles/1/vulnerability_preferences/:id',
          (schema, req) => {
            const { comment, risk } = getReqBodyObjFromReqBodyStr(req);

            // Selected overriden risk
            assert.strictEqual(Number(risk), riskToEditTo);

            return {
              id: req.params.id,
              risk,
              comment,
              overridden_by: null,
              overridden_date: null,
            };
          }
        );

        // Test Variables
        const isAlreadyEdited = !isEmpty(risk);

        const markAsIgnored = riskToEditTo === ENUMS.RISK.NONE;
        const editReason = 'test';

        // Vulnerability preference
        const vulnPref = this.server.create('vulnerability-preference', {
          risk,
          comment: isAlreadyEdited ? `${riskText([risk])} test` : null,
        });

        const relatedVulnerability = this.createRelatedVulnerability(vulnPref);

        const ELEMENT_SELECTORS = isAlreadyEdited
          ? OVERIDED_DETAILS_SELECTORS
          : GENERAL_SELECTORS;

        await render(
          hbs`<ProjectSettings::AnalysisSettings::VulnerabilityList @project={{this.project}} />`
        );

        assert.dom('[data-test-vulnerability-list-container]').exists();

        let numberOfVulnerabilityItems = this.element.querySelectorAll(
          ELEMENT_SELECTORS.vulnPrefRowItem
        );

        // Sanity check for vulnerability details

        assert
          .dom(ELEMENT_SELECTORS.vulnPrefName, numberOfVulnerabilityItems[0])
          .exists()
          .hasText(relatedVulnerability.name);

        assert
          .dom(ELEMENT_SELECTORS.actionBtn, numberOfVulnerabilityItems[0])
          .exists();

        if (isAlreadyEdited) {
          assert
            .dom(ELEMENT_SELECTORS.overridenIcon, numberOfVulnerabilityItems[0])
            .exists();

          assert
            .dom(ELEMENT_SELECTORS.riskTag, numberOfVulnerabilityItems[0])
            .exists()
            .hasText(getAnalysisRiskText(vulnPref.risk));
        } else {
          assert
            .dom(ELEMENT_SELECTORS.editIcon, numberOfVulnerabilityItems[0])
            .exists()
            .hasClass(/ak-icon-edit/);

          assert
            .dom(ELEMENT_SELECTORS.riskTag, numberOfVulnerabilityItems[0])
            .doesNotExist();
        }

        // Edit sequence of vulnerability preference
        await click(ELEMENT_SELECTORS.actionBtn);

        checkOverrideEditDrawerDetails(assert, vulnPref, relatedVulnerability);

        if (isAlreadyEdited) {
          await click(ELEMENT_SELECTORS.OEFEditBtn);
        }

        await click(`.${OEFOverrideToSelectClasses.trigger}`);

        assert.dom(`.${OEFOverrideToSelectClasses.dropdown}`).exists();

        // Should not contain a selected override option if unedited
        let selectListItems = findAll(`.ember-power-select-option`);
        const allRiskChoicesValues = OVERRIDE_RISKS_CHOICES.map(
          (op) => op.value
        );

        // Select risk to override to
        const currentRiskOptionIdx = allRiskChoicesValues.indexOf(risk);

        if (isAlreadyEdited) {
          assert
            .dom(selectListItems[currentRiskOptionIdx])
            .hasAria('selected', 'true');
        } else {
          selectListItems.forEach((it) =>
            assert.dom(it).hasAria('selected', 'false')
          );
        }

        // Select risk to override to
        const riskToSelectIdx = allRiskChoicesValues.indexOf(riskToEditTo);

        await selectChoose(
          `.${OEFOverrideToSelectClasses.trigger}`,
          markAsIgnored
            ? t('ignoreVulnerability')
            : t(riskText([OVERRIDE_RISKS_CHOICES[riskToSelectIdx]]))
        );

        if (markAsIgnored) {
          assert
            .dom(GENERAL_SELECTORS.OEFOverrideSelectHelperText)
            .exists()
            .containsText(
              t(
                'projectSettings.vulnerabilityPreference.ignoreVulnerabilityHelperText'
              )
            );
        }

        await click(`.${OEFOverrideToSelectClasses.trigger}`);

        // Refresh select items list
        selectListItems = findAll(`.ember-power-select-option`);

        assert
          .dom(selectListItems[riskToSelectIdx])
          .hasAria('selected', 'true');

        await click(`.${OEFOverrideToSelectClasses.trigger}`);

        assert
          .dom(GENERAL_SELECTORS.overrideEditDrawerDivider)
          .exists()
          .hasText(t('for'));

        assert
          .dom(GENERAL_SELECTORS.OEFOverrideCriteriaText)
          .exists()
          .hasText(t('allFutureAnalyses'));

        // Type reason
        assert
          .dom(GENERAL_SELECTORS.OEFCommentLabel)
          .exists()
          .hasText(t('reason'));

        await fillIn(GENERAL_SELECTORS.OEFCommentInput, editReason);

        assert.dom(GENERAL_SELECTORS.OEFCommentInput).hasValue(editReason);

        // Save edited risk
        await click(GENERAL_SELECTORS.OEFSaveBtn);

        if (isAlreadyEdited) {
          const riskLabelSelector = `${ELEMENT_SELECTORS.OEFVulnerabilityRiskTag} [data-test-analysisRiskTag-label]`;

          assert
            .dom(riskLabelSelector)
            .containsText(getAnalysisRiskText(riskToEditTo)); // Confirm that risk is edited properly
        } else {
          assert.dom(GENERAL_SELECTORS.OEFSuccessSvg).exists();

          assert
            .dom(GENERAL_SELECTORS.OEFSuccessMsg)
            .exists()
            .containsText(
              t(
                'projectSettings.vulnerabilityPreference.overrideSuccessMessage'
              )
            );
        }

        await click(GENERAL_SELECTORS.overrideEditDrawerCloseBtn);

        // refresh vulnerability preference list
        numberOfVulnerabilityItems = this.element.querySelectorAll(
          GENERAL_SELECTORS.vulnPrefRowItem
        );

        // Sanity check for edited vulnerability preference
        assert
          .dom(GENERAL_SELECTORS.actionBtn, numberOfVulnerabilityItems[0])
          .exists();

        assert
          .dom(GENERAL_SELECTORS.overridenIcon, numberOfVulnerabilityItems[0])
          .exists();

        assert
          .dom(GENERAL_SELECTORS.riskTag, numberOfVulnerabilityItems[0])
          .exists()
          .containsText(getAnalysisRiskText(riskToEditTo));
      }
    );

    test.each(
      'it should not edit vulnerability preference if edit comment or risk is not provided',
      [
        // No Risk -> Risk
        {
          risk: null,
          riskToEditTo: ENUMS.RISK.CRITICAL,
          expected: 40,
        },
        // Risk -> Passed
        {
          risk: ENUMS.RISK.CRITICAL,
          riskToEditTo: ENUMS.RISK.NONE,
          expected: 44,
        },
      ],
      async function (assert, { risk, riskToEditTo, expected }) {
        assert.expect(expected);

        // Server Mocks
        this.server.put(
          '/profiles/1/vulnerability_preferences/:id',
          (schema, req) => {
            const { comment, risk } = getReqBodyObjFromReqBodyStr(req);

            // Selected overriden risk
            assert.strictEqual(Number(risk), riskToEditTo);

            return {
              id: req.params.id,
              risk,
              comment,
              overridden_by: null,
              overridden_date: null,
            };
          }
        );

        // Test Variables
        const isAlreadyEdited = !isEmpty(risk);

        const markAsIgnored = riskToEditTo === ENUMS.RISK.NONE;
        const editReason = 'test';

        // Vulnerability preference
        const vulnPref = this.server.create('vulnerability-preference', {
          risk,
          comment: isAlreadyEdited ? `${riskText([risk])} test` : null,
        });

        const relatedVulnerability = this.createRelatedVulnerability(vulnPref);

        const ELEMENT_SELECTORS = isAlreadyEdited
          ? OVERIDED_DETAILS_SELECTORS
          : GENERAL_SELECTORS;

        await render(
          hbs`<ProjectSettings::AnalysisSettings::VulnerabilityList @project={{this.project}} />`
        );

        assert.dom('[data-test-vulnerability-list-container]').exists();

        let numberOfVulnerabilityItems = this.element.querySelectorAll(
          ELEMENT_SELECTORS.vulnPrefRowItem
        );

        // Sanity check for vulnerability details

        assert
          .dom(ELEMENT_SELECTORS.vulnPrefName, numberOfVulnerabilityItems[0])
          .exists()
          .hasText(relatedVulnerability.name);

        assert
          .dom(ELEMENT_SELECTORS.actionBtn, numberOfVulnerabilityItems[0])
          .exists();

        if (isAlreadyEdited) {
          assert
            .dom(ELEMENT_SELECTORS.overridenIcon, numberOfVulnerabilityItems[0])
            .exists();

          assert
            .dom(ELEMENT_SELECTORS.riskTag, numberOfVulnerabilityItems[0])
            .exists()
            .hasText(getAnalysisRiskText(vulnPref.risk));
        } else {
          assert
            .dom(ELEMENT_SELECTORS.editIcon, numberOfVulnerabilityItems[0])
            .exists()
            .hasClass(/ak-icon-edit/);

          assert
            .dom(ELEMENT_SELECTORS.riskTag, numberOfVulnerabilityItems[0])
            .doesNotExist();
        }

        // Edit sequence of vulnerability preference
        await click(ELEMENT_SELECTORS.actionBtn);

        checkOverrideEditDrawerDetails(assert, vulnPref, relatedVulnerability);

        if (isAlreadyEdited) {
          await click(ELEMENT_SELECTORS.OEFEditBtn);
        }

        await click(`.${OEFOverrideToSelectClasses.trigger}`);

        assert.dom(`.${OEFOverrideToSelectClasses.dropdown}`).exists();

        // Should not contain a selected override option if unedited
        let selectListItems = findAll(`.ember-power-select-option`);
        const allRiskChoicesValues = OVERRIDE_RISKS_CHOICES.map(
          (op) => op.value
        );

        // Select risk to override to
        const currentRiskOptionIdx = allRiskChoicesValues.indexOf(risk);

        if (isAlreadyEdited) {
          assert
            .dom(selectListItems[currentRiskOptionIdx])
            .hasAria('selected', 'true');
        } else {
          selectListItems.forEach((it) =>
            assert.dom(it).hasAria('selected', 'false')
          );
        }

        // Select risk to override to
        const riskToSelectIdx = allRiskChoicesValues.indexOf(riskToEditTo);

        if (isEmpty(risk)) {
          // Save edit without selecting a risk
          await click(GENERAL_SELECTORS.OEFSaveBtn);

          assert
            .dom(GENERAL_SELECTORS.OEFRiskCriteriaSelectErrorText)
            .exists()
            .hasText(t('editOverrideVulnerability.emptySeverityErrorText'));
        }

        await selectChoose(
          `.${OEFOverrideToSelectClasses.trigger}`,
          markAsIgnored
            ? t('ignoreVulnerability')
            : t(riskText([OVERRIDE_RISKS_CHOICES[riskToSelectIdx]]))
        );

        assert
          .dom(GENERAL_SELECTORS.OEFRiskCriteriaSelectErrorText)
          .doesNotExist();

        if (markAsIgnored) {
          assert
            .dom(GENERAL_SELECTORS.OEFOverrideSelectHelperText)
            .exists()
            .containsText(
              t(
                'projectSettings.vulnerabilityPreference.ignoreVulnerabilityHelperText'
              )
            );
        }

        await click(`.${OEFOverrideToSelectClasses.trigger}`);

        // Refresh select items list
        selectListItems = findAll(`.ember-power-select-option`);

        assert
          .dom(selectListItems[riskToSelectIdx])
          .hasAria('selected', 'true');

        await click(`.${OEFOverrideToSelectClasses.trigger}`);

        // Clear comment if already available
        if (isAlreadyEdited) {
          await fillIn(GENERAL_SELECTORS.OEFCommentInput, '');

          // Save edit without adding a comment
          await click(GENERAL_SELECTORS.OEFSaveBtn);

          assert
            .dom(GENERAL_SELECTORS.OEFCommentInput)
            .hasClass(/textarea-error/);

          assert
            .dom(GENERAL_SELECTORS.OEFCommentInputErrorText)
            .exists()
            .hasText(t('editOverrideVulnerability.emptyReasonErrorText'));
        }

        // Type reason
        assert
          .dom(GENERAL_SELECTORS.OEFCommentLabel)
          .exists()
          .hasText(t('reason'));

        await fillIn(GENERAL_SELECTORS.OEFCommentInput, editReason);

        assert.dom(GENERAL_SELECTORS.OEFCommentInput).hasValue(editReason);

        assert
          .dom(GENERAL_SELECTORS.OEFCommentInput)
          .hasNoClass(/textarea-error/);

        assert.dom(GENERAL_SELECTORS.OEFCommentInputErrorText).doesNotExist();

        // Save edited risk
        await click(GENERAL_SELECTORS.OEFSaveBtn);

        await click(GENERAL_SELECTORS.overrideEditDrawerCloseBtn);

        // refresh vulnerability preference list
        numberOfVulnerabilityItems = this.element.querySelectorAll(
          GENERAL_SELECTORS.vulnPrefRowItem
        );

        // Sanity check for edited vulnerability preference
        assert
          .dom(GENERAL_SELECTORS.actionBtn, numberOfVulnerabilityItems[0])
          .exists();

        assert
          .dom(GENERAL_SELECTORS.overridenIcon, numberOfVulnerabilityItems[0])
          .exists();

        assert
          .dom(GENERAL_SELECTORS.riskTag, numberOfVulnerabilityItems[0])
          .exists()
          .containsText(getAnalysisRiskText(riskToEditTo));
      }
    );

    test.each(
      'it resets an edited vulnerability preference',
      [ENUMS.RISK.CRITICAL, ENUMS.RISK.NONE],
      async function (assert, risk) {
        assert.expect(39);

        // Server Mocks
        this.server.get('/profiles/:id/vulnerability_preferences', (schema) => {
          return schema['vulnerabilityPreferences'].all().models;
        });

        this.server.put(
          '/profiles/1/vulnerability_preferences/:id',
          (schema, req) => {
            const { comment, risk } = getReqBodyObjFromReqBodyStr(req);

            // Selected overriden risk
            assert.true(isEmpty(risk));
            assert.true(isEmpty(comment));

            return {
              id: req.params.id,
              risk,
              comment,
              overridden_by: null,
              overridden_date: null,
            };
          }
        );

        // Vulnerability preference
        const vulnPref = this.server.create('vulnerability-preference', {
          risk,
          comment: `${riskText([risk])} test`,
        });

        const relatedVulnerability = this.createRelatedVulnerability(vulnPref);

        await render(
          hbs`<ProjectSettings::AnalysisSettings::VulnerabilityList @project={{this.project}} />`
        );

        assert.dom('[data-test-vulnerability-list-container]').exists();

        let numberOfVulnerabilityItems = this.element.querySelectorAll(
          GENERAL_SELECTORS.vulnPrefRowItem
        );

        // Sanity check for vulnerability details

        assert
          .dom(GENERAL_SELECTORS.vulnPrefName, numberOfVulnerabilityItems[0])
          .exists()
          .hasText(relatedVulnerability.name);

        assert
          .dom(GENERAL_SELECTORS.actionBtn, numberOfVulnerabilityItems[0])
          .exists();

        assert
          .dom(GENERAL_SELECTORS.overridenIcon, numberOfVulnerabilityItems[0])
          .exists();

        assert
          .dom(GENERAL_SELECTORS.riskTag, numberOfVulnerabilityItems[0])
          .exists()
          .hasText(getAnalysisRiskText(vulnPref.risk));

        // Edit sequence of vulnerability preference
        await click(GENERAL_SELECTORS.actionBtn);

        checkOverrideEditDrawerDetails(assert, vulnPref, relatedVulnerability);

        await click(GENERAL_SELECTORS.OEFResetBtn);

        assert
          .dom(GENERAL_SELECTORS.overrideEditDrawerTitle)
          .exists()
          .containsText(t('confirmation'));

        assert
          .dom(
            '[data-test-prjSettings-analysisSettings-vulnPreference-resetConfirm-confirmTitle]'
          )
          .exists()
          .containsText(
            t('projectSettings.vulnerabilityPreference.resetConfirmTitle')
          );

        await click(
          `[data-test-prjSettings-analysisSettings-vulnPreference-resetConfirm-resetaction="${t('yes')}"]`
        );

        assert
          .dom(
            '[data-test-prjSettings-analysisSettings-vulnPreference-resetConfirm-successSvg]'
          )
          .exists();

        assert
          .dom(
            '[data-test-prjSettings-analysisSettings-vulnPreference-resetConfirm-successSvg]'
          )
          .exists();

        assert
          .dom(
            '[data-test-prjSettings-analysisSettings-vulnPreference-resetConfirm-successMsg]'
          )
          .exists()
          .hasText(
            t('projectSettings.vulnerabilityPreference.resetSuccessMessage')
          );

        await click(GENERAL_SELECTORS.overrideEditDrawerCloseBtn);

        // refresh vulnerability preference list
        numberOfVulnerabilityItems = this.element.querySelectorAll(
          GENERAL_SELECTORS.vulnPrefRowItem
        );

        // Sanity check for edited vulnerability preference
        assert
          .dom(GENERAL_SELECTORS.actionBtn, numberOfVulnerabilityItems[0])
          .exists();

        assert
          .dom(GENERAL_SELECTORS.editIcon, numberOfVulnerabilityItems[0])
          .exists()
          .hasClass(/ak-icon-edit/);

        assert
          .dom(GENERAL_SELECTORS.riskTag, numberOfVulnerabilityItems[0])
          .doesNotExist();
      }
    );
  }
);
