import Service from '@ember/service';
import { click, fillIn, render, select } from '@ember/test-helpers';
import { hbs } from 'ember-cli-htmlbars';
import { setupMirage } from 'ember-cli-mirage/test-support';
import { setupIntl } from 'ember-intl/test-support';
import { setupRenderingTest } from 'ember-qunit';
import ENUMS from 'irene/enums';
import { riskText } from 'irene/helpers/risk-text';
import { module, test } from 'qunit';

class NotificationsStub extends Service {
  errorMsg = null;
  successMsg = null;
  error(msg) {
    this.errorMsg = msg;
    return this.errorMsg;
  }

  success(msg) {
    this.successMsg = msg;
    return this.successMsg;
  }
}

class OrganizationStub extends Service {
  selected = {
    id: 1,
    features: {
      manualscan: true,
    },
  };
}

module('Integration | Component | vulnerability-details', function (hooks) {
  setupRenderingTest(hooks);
  setupMirage(hooks);
  setupIntl(hooks);

  hooks.beforeEach(async function () {
    this.project = this.server.create('project', {
      activeProfileId: 1,
    });

    this.vulnerabilityPreference = this.server.create(
      'vulnerability-preference'
    );

    this.vulnerability = this.owner
      .lookup('service:store')
      .createRecord('vulnerability', {
        id: 1,
        name: 'Appknox Vulnerability',
      });

    this.owner.register('service:notifications', NotificationsStub);
    this.notifyService = this.owner.lookup('service:notifications');

    // Risk select options
    const risks = ENUMS.RISK.CHOICES;
    const riskFilter = [ENUMS.RISK.NONE, ENUMS.RISK.UNKNOWN];
    this.riskSelectOptions = risks.filter(
      (risk) => !riskFilter.includes(risk.value)
    );
  });

  test('it renders correctly when risk overridden is false.', async function (assert) {
    this.owner.register('service:organization', OrganizationStub);

    assert.expect(9);

    await render(
      hbs`<VulnerabilityDetails @project={{this.project}} @vulnerability={{this.vulnerabilityPreference}}  />`
    );

    assert
      .dom('[data-test-vulnerability-details-name]')
      .exists()
      .hasText(this.vulnerability.name);

    const risksSelect = this.element.querySelector(
      '[data-test-risk-select-preferences]'
    );

    const riskSelectOptions = this.element.querySelectorAll(
      '[data-test-risk-select-preferences-option]'
    );

    assert.dom(risksSelect).exists();

    // The select contain an extra option {{t 'selectRisk'}} === "Select Risk"
    assert.strictEqual(
      riskSelectOptions.length,
      this.riskSelectOptions.length + 1,
      'Risk select element contains correct options count'
    );

    assert.strictEqual(
      riskSelectOptions[0].innerText.trim(),
      't:selectRisk:()',
      'First select option value is t:selectRisk:()'
    );

    for (let idx = 0; idx < this.riskSelectOptions.length; idx++) {
      const optionElement = riskSelectOptions[idx + 1];
      const optionElementInnerText = optionElement.innerText.trim();
      const optionRiskValue = riskText([this.riskSelectOptions[idx].value]);

      assert.strictEqual(
        optionElementInnerText,
        `t:${optionRiskValue}:()`,
        `[data-test-risk-select-preferences-option] ${
          idx + 1
        } equals ${optionElementInnerText}`
      );
    }
  });

  test('it renders correctly when risk overridden is true', async function (assert) {
    this.owner.register('service:organization', OrganizationStub);

    this.vulnerabilityPreference = this.server.create(
      'vulnerability-preference',
      { risk: 0, comment: 'No comments' }
    );

    await render(
      hbs`<VulnerabilityDetails @project={{this.project}} @vulnerability={{this.vulnerabilityPreference}}  />`
    );

    const riskLabelClassElementClassName = this.element.querySelector(
      '[data-test-vulnerability-risk-label-class]'
    ).className;

    const riskLabelIconClassName = this.element.querySelector(
      '[data-test-vulnerability-risk-label-class] i'
    ).className;

    assert.dom('[data-test-vulnerability-risk-label-class]').exists();
    assert.ok(
      riskLabelClassElementClassName.includes(
        this.vulnerabilityPreference.riskLabelClass
      ),
      `Risk label class contains ${this.vulnerabilityPreference.riskLabelClass}`
    );
    assert.ok(
      riskLabelIconClassName.includes(
        this.vulnerabilityPreference.riskIconClass
      ),
      `Risk label icon class contains ${this.vulnerabilityPreference.riskIconClass}`
    );

    const overridenRiskText = riskText([this.vulnerabilityPreference.risk]);
    assert
      .dom('[data-test-vulnerability-risk-label-text]')
      .exists()
      .containsText(`t:${overridenRiskText}:()`);

    assert.dom('[data-test-vulnerability-risk-edit]').exists();

    assert
      .dom('[data-test-vulnerability-edit-tooltip]')
      .exists()
      .containsText(`t:editAnalysis:()`);

    assert.dom('[data-test-risk-reset-btn]').exists();
    assert
      .dom('[data-test-vulnerability-reset-tooltip]')
      .exists()
      .containsText(`t:reset:()`);

    assert
      .dom('[data-test-risk-overridden-comment-label]')
      .exists()
      .containsText(`t:comment:()`);

    assert
      .dom('[data-test-risk-overridden-comment-text]')
      .exists()
      .containsText(this.vulnerabilityPreference.comment);
  });

  test('it shows "none" text placeholder when risk is overriden with no comment', async function (assert) {
    this.owner.register('service:organization', OrganizationStub);

    this.vulnerabilityPreference = this.server.create(
      'vulnerability-preference',
      { risk: 0, comment: '' }
    );

    await render(
      hbs`<VulnerabilityDetails @project={{this.project}} @vulnerability={{this.vulnerabilityPreference}}  />`
    );

    assert
      .dom('[data-test-risk-overridden-comment-no-text]')
      .exists()
      .containsText(`t:none:()`);
  });

  test('it displays comment box and edit CTA buttons when risk select option changes and risk overriden is false', async function (assert) {
    this.owner.register('service:organization', OrganizationStub);

    this.vulnerabilityPreference = this.server.create(
      'vulnerability-preference',
      { comment: '' }
    );

    await render(
      hbs`<VulnerabilityDetails @project={{this.project}} @vulnerability={{this.vulnerabilityPreference}}  />`
    );

    const riskSelectOptions = this.element.querySelectorAll(
      '[data-test-risk-select-preferences-option]'
    );

    await select(
      '[data-test-risk-select-preferences]',
      riskSelectOptions[1].value
    );

    assert.dom('[data-test-risk-edit-container]').exists();

    assert
      .dom('[data-test-risk-edit-comment-label]')
      .exists()
      .hasText('t:comment:()');

    assert
      .dom('[data-test-risk-edit-comment-text-area]')
      .exists()
      .hasText(`${this.vulnerabilityPreference.comment}`);

    assert
      .dom('[data-test-risk-edit-save-btn]')
      .exists()
      .containsText('t:save:()');

    assert
      .dom('[data-test-risk-edit-cancel-btn]')
      .exists()
      .containsText('t:cancel:()');
  });

  test('it hides edit comment box and edit CTA buttons when the cancel button is clicked', async function (assert) {
    this.owner.register('service:organization', OrganizationStub);

    this.vulnerabilityPreference = this.server.create(
      'vulnerability-preference',
      { comment: '' }
    );

    await render(
      hbs`<VulnerabilityDetails @project={{this.project}} @vulnerability={{this.vulnerabilityPreference}}  />`
    );

    const riskSelectOptions = this.element.querySelectorAll(
      '[data-test-risk-select-preferences-option]'
    );

    await select(
      '[data-test-risk-select-preferences]',
      riskSelectOptions[1].value
    );

    assert.dom('[data-test-risk-edit-container]').exists();

    await click('[data-test-risk-edit-cancel-btn]');

    assert.dom('[data-test-risk-edit-container]').doesNotExist();
  });

  test('it throws an error when editing if comment is empty or risk is invalid', async function (assert) {
    this.owner.register('service:organization', OrganizationStub);

    this.vulnerabilityPreference = this.server.create(
      'vulnerability-preference',
      { comment: '' }
    );

    await render(
      hbs`<VulnerabilityDetails @project={{this.project}} @vulnerability={{this.vulnerabilityPreference}}  />`
    );

    const riskSelectOptions = this.element.querySelectorAll(
      '[data-test-risk-select-preferences-option]'
    );

    await select(
      '[data-test-risk-select-preferences]',
      riskSelectOptions[0].value
    );

    assert.dom('[data-test-risk-edit-container]').exists();
    await click('[data-test-risk-edit-save-btn]');

    assert.strictEqual(
      this.notifyService.get('errorMsg'),
      `t:riskAndCommentRequired:()`,
      'Error notification message is t:riskAndCommentRequired:()'
    );

    // Enter a value for comment
    await fillIn(`[data-test-risk-edit-comment-text-area]`, 'comment');
    assert.dom('[data-test-risk-edit-comment-text-area]').hasValue('comment');

    // The selected option is still invalid
    await click('[data-test-risk-edit-save-btn]');

    assert.strictEqual(
      this.notifyService.get('errorMsg'),
      `t:riskAndCommentRequired:()`,
      'Error notification message is t:riskAndCommentRequired:()'
    );
  });

  test('it should not throw an error after editing if comment and risk are valid', async function (assert) {
    this.owner.register('service:organization', OrganizationStub);

    this.vulnerabilityPreference = this.server.create(
      'vulnerability-preference',
      { comment: '' }
    );

    await render(
      hbs`<VulnerabilityDetails @project={{this.project}} @vulnerability={{this.vulnerabilityPreference}}  />`
    );

    const riskSelectOptions = this.element.querySelectorAll(
      '[data-test-risk-select-preferences-option]'
    );

    await select(
      '[data-test-risk-select-preferences]',
      riskSelectOptions[1].value
    );

    // Enter a value for comment
    await fillIn(`[data-test-risk-edit-comment-text-area]`, 'comment');

    await click('[data-test-risk-edit-save-btn]');

    assert.strictEqual(
      this.notifyService.get('errorMsg'),
      null,
      'Error notification message should not exist'
    );
  });

  test('it saves vulnerability changes when save button is clicked during editing', async function (assert) {
    this.owner.register('service:organization', OrganizationStub);

    this.vulnerabilityPreference = this.server.create(
      'vulnerability-preference',
      { id: 1, comment: '', risk: null }
    );

    this.server.put(
      '/profiles/:id/vulnerability_preferences/:id',
      (schema, request) => {
        const body = new URLSearchParams(request.requestBody);
        const comment = body.get('comment');
        const risk = body.get('risk');

        return {
          id: request.params.id,
          risk,
          comment,
        };
      }
    );

    await render(
      hbs`<VulnerabilityDetails @project={{this.project}} @vulnerability={{this.vulnerabilityPreference}}  />`
    );

    const riskSelectOptions = this.element.querySelectorAll(
      '[data-test-risk-select-preferences-option]'
    );

    await select(
      '[data-test-risk-select-preferences]',
      riskSelectOptions[3].value // Selects the second item on the list
    );

    assert.dom('[data-test-risk-edit-container]').exists();

    await fillIn(`[data-test-risk-edit-comment-text-area]`, 'comment edited');
    await click('[data-test-risk-edit-save-btn]');

    assert.dom('[data-test-risk-edit-container]').doesNotExist();

    const overridenRiskText = riskText([riskSelectOptions[3].value]);
    assert
      .dom('[data-test-vulnerability-risk-label-text]')
      .exists()
      .containsText(`t:${overridenRiskText}:()`);

    assert.dom('[data-test-vulnerability-risk-edit]').exists();

    assert
      .dom('[data-test-vulnerability-edit-tooltip]')
      .exists()
      .containsText(`t:editAnalysis:()`);

    assert.dom('[data-test-risk-reset-btn]').exists();
    assert
      .dom('[data-test-vulnerability-reset-tooltip]')
      .exists()
      .containsText(`t:reset:()`);

    assert
      .dom('[data-test-risk-overridden-comment-label]')
      .exists()
      .containsText(`t:comment:()`);

    assert
      .dom('[data-test-risk-overridden-comment-text]')
      .exists()
      .containsText('comment edited');
  });

  test('it edits an overriden vulnerability correctly', async function (assert) {
    this.owner.register('service:organization', OrganizationStub);

    this.vulnerabilityPreference = this.server.create(
      'vulnerability-preference',
      { id: 1, comment: 'initial comment', risk: ENUMS.RISK.LOW }
    );

    this.server.put(
      '/profiles/:id/vulnerability_preferences/:id',
      (schema, request) => {
        const body = new URLSearchParams(request.requestBody);
        const comment = body.get('comment');
        const risk = body.get('risk');

        return {
          id: request.params.id,
          risk,
          comment,
        };
      }
    );

    await render(
      hbs`<VulnerabilityDetails @project={{this.project}} @vulnerability={{this.vulnerabilityPreference}}  />`
    );

    assert.dom('[data-test-risk-edit-container]').doesNotExist();

    const initialOverridenRiskText = riskText([
      this.vulnerabilityPreference.risk,
    ]);

    assert
      .dom('[data-test-vulnerability-risk-label-text]')
      .exists()
      .containsText(`t:${initialOverridenRiskText}:()`);

    assert.dom('[data-test-vulnerability-risk-edit]').exists();

    assert
      .dom('[data-test-vulnerability-edit-tooltip]')
      .exists()
      .containsText(`t:editAnalysis:()`);

    assert.dom('[data-test-risk-reset-btn]').exists();

    assert
      .dom('[data-test-risk-overridden-comment-text]')
      .exists()
      .containsText(this.vulnerabilityPreference.comment);

    await click('[data-test-vulnerability-risk-edit]');

    assert.dom('[data-test-risk-edit-select-preferences]').exists();
    assert.dom('[data-test-risk-edit-container]').exists();
    assert.dom('[data-test-risk-edit-save-btn]').exists();
    assert.dom('[data-test-risk-edit-cancel-btn]').exists();

    const editRiskSelectOptions = this.element.querySelectorAll(
      '[data-test-risk-edit-select-preferences-option]'
    );

    await select(
      '[data-test-risk-edit-select-preferences]',
      editRiskSelectOptions[2].value // Selects the second item on the list
    );

    await fillIn(`[data-test-risk-edit-comment-text-area]`, 'comment edited');
    await click('[data-test-risk-edit-save-btn]');

    assert.dom('[data-test-risk-edit-container]').doesNotExist();
    assert.dom('[data-test-risk-edit-save-btn]').doesNotExist();
    assert.dom('[data-test-risk-edit-cancel-btn]').doesNotExist();

    const overridenRiskText = riskText([editRiskSelectOptions[2].value]);
    assert
      .dom('[data-test-vulnerability-risk-label-text]')
      .exists()
      .containsText(`t:${overridenRiskText}:()`);

    assert.dom('[data-test-vulnerability-risk-edit]').exists();

    assert
      .dom('[data-test-vulnerability-reset-tooltip]')
      .exists()
      .containsText(`t:reset:()`);

    assert
      .dom('[data-test-risk-overridden-comment-label]')
      .exists()
      .containsText(`t:comment:()`);

    assert
      .dom('[data-test-risk-overridden-comment-text]')
      .exists()
      .containsText('comment edited');
  });

  test('it resets an overriden vulnerability correctly', async function (assert) {
    this.owner.register('service:organization', OrganizationStub);

    this.vulnerabilityPreference = this.server.create(
      'vulnerability-preference',
      { id: 1, comment: 'initial comment', risk: ENUMS.RISK.LOW }
    );

    this.server.put(
      '/profiles/:id/vulnerability_preferences/:id',
      (schema, request) => {
        const body = new URLSearchParams(request.requestBody);
        const comment = body.get('comment');
        const risk = body.get('risk');

        return {
          id: request.params.id,
          risk,
          comment,
        };
      }
    );

    await render(
      hbs`<VulnerabilityDetails @project={{this.project}} @vulnerability={{this.vulnerabilityPreference}}  />`
    );

    assert.dom('[data-test-risk-edit-container]').doesNotExist();

    const initialOverridenRiskText = riskText([
      this.vulnerabilityPreference.risk,
    ]);

    assert
      .dom('[data-test-vulnerability-risk-label-text]')
      .exists()
      .containsText(`t:${initialOverridenRiskText}:()`);

    assert.dom('[data-test-vulnerability-risk-edit]').exists();

    assert
      .dom('[data-test-vulnerability-edit-tooltip]')
      .exists()
      .containsText(`t:editAnalysis:()`);

    assert.dom('[data-test-risk-reset-btn]').exists();

    await click('[data-test-risk-reset-btn]');

    assert.dom('[data-test-risk-overridden-comment]').doesNotExist();
    assert
      .dom('[data-test-risk-select-preferences]')
      .hasValue('t:selectRisk:()');
  });

  test('it shows vulnerability if manual scan feature is disabled and vulnerability types do not include manual scan', async function (assert) {
    this.vulnerability.types = [ENUMS.VULNERABILITY_TYPE.DYNAMIC];

    this.vulnerabilityPreference = this.server.create(
      'vulnerability-preference',
      { id: 1, comment: 'initial comment', risk: ENUMS.RISK.LOW }
    );

    this.server.put(
      '/profiles/:id/vulnerability_preferences/:id',
      (schema, request) => {
        const body = new URLSearchParams(request.requestBody);
        const comment = body.get('comment');
        const risk = body.get('risk');

        return {
          id: request.params.id,
          risk,
          comment,
        };
      }
    );

    class OrganizationStub extends Service {
      selected = {
        id: 1,
        features: {
          manualscan: false,
        },
      };
    }

    this.owner.register('service:organization', OrganizationStub);

    await render(
      hbs`<VulnerabilityDetails @project={{this.project}} @vulnerability={{this.vulnerabilityPreference}}  />`
    );

    assert.dom('[data-test-vulnerability-details-container]').exists();
  });
});
