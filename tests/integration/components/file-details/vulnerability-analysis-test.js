import { click, findAll, render } from '@ember/test-helpers';
import { hbs } from 'ember-cli-htmlbars';
import { setupMirage } from 'ember-cli-mirage/test-support';
import { setupIntl } from 'ember-intl/test-support';
import { setupRenderingTest } from 'ember-qunit';
import { module, test } from 'qunit';
import styles from 'irene/components/ak-select/index.scss';
import { selectChoose } from 'ember-power-select/test-support';

import { Response } from 'miragejs';
import Service from '@ember/service';

import ENUMS from 'irene/enums';
import { analysisRiskStatus } from 'irene/helpers/analysis-risk-status';

class NotificationsStub extends Service {
  errorMsg = null;
  successMsg = null;

  error(msg) {
    this.errorMsg = msg;
  }
  success(msg) {
    this.successMsg = msg;
  }
}

class RouterStub extends Service {
  transitionToArgs = [];

  transitionTo() {
    this.transitionToArgs = arguments;
  }

  on() {}

  off() {}
}

const vulnerabilityTypeTextMap = {
  [ENUMS.VULNERABILITY_TYPE.STATIC]: 'static',
  [ENUMS.VULNERABILITY_TYPE.DYNAMIC]: 'dynamic',
  [ENUMS.VULNERABILITY_TYPE.MANUAL]: 'manual',
  [ENUMS.VULNERABILITY_TYPE.API]: 'api',
};

const classes = {
  dropdown: styles['ak-select-dropdown'],
  trigger: styles['ak-select-trigger'],
  triggerError: styles['ak-select-trigger-error'],
};

module(
  'Integration | Component | file-details/vulnerability-analysis',
  function (hooks) {
    setupRenderingTest(hooks);
    setupMirage(hooks);
    setupIntl(hooks);

    hooks.beforeEach(async function () {
      this.server.createList('organization', 1);

      const store = this.owner.lookup('service:store');

      //   create and push to store
      const vulnerabilities = this.server.createList('vulnerability', 5).reduce(
        (acc, curr) => [
          ...acc,
          store.push(
            store.normalize('vulnerability', {
              attributes: curr.toJSON(),
              id: curr.id,
              relationships: {},
              type: 'vulnerabilities',
            })
          ),
        ],
        []
      );

      const analyses = vulnerabilities.map((v) =>
        this.server.create('analysis', {
          vulnerability: v.id,
          file: '1',
          status: ENUMS.ANALYSIS_STATUS.COMPLETED,
        })
      );

      const file = this.server.create('file', {
        project: '1',
        analyses: analyses.map((a) => a.toJSON()),
      });

      this.server.create('project', { file: file.id, id: '1' });

      this.setProperties({
        file: store.push(store.normalize('file', file.toJSON())),
        vulnerabilities,
        store,
      });

      await this.owner.lookup('service:organization').load();
      this.owner.register('service:notifications', NotificationsStub);
      this.owner.register('service:router', RouterStub);
    });

    test('it renders file-details/vulnerability-analysis', async function (assert) {
      this.server.get('/v2/projects/:id', (schema, req) => {
        return schema.projects.find(`${req.params.id}`)?.toJSON();
      });

      this.server.get('/hudson-api/projects', () => {
        return new Response(403);
      });

      await render(hbs`
        <FileDetails::VulnerabilityAnalysis @file={{this.file}} />
      `);

      assert
        .dom('[data-test-vulnerability-analysis-title]')
        .hasText('t:vulnerabilityDetails:()');

      assert
        .dom('[data-test-vulnerability-analysis-description]')
        .hasText('t:fileVulnerabilityDetailsDescription:()');

      assert
        .dom('[data-test-vulnerability-analysis-editAnalysesLink]')
        .doesNotExist();

      assert.dom('[data-test-vulnerability-analysis-filterSelect]').exists();

      assert.dom('[data-test-vulnerability-analysis-table]').exists();

      const headerCells = findAll(
        '[data-test-vulnerability-analysis-thead] th'
      );

      assert.strictEqual(headerCells.length, 3);

      assert.dom(headerCells[0]).hasText('t:impact:()');
      assert.dom(headerCells[1]).hasText('t:title:()');
      assert.dom(headerCells[2]).hasText('t:typeOfScan:()');

      const rows = findAll('[data-test-vulnerability-analysis-row]');

      assert.strictEqual(rows.length, this.file.analyses.length);

      // assert first row
      const firstRowCells = rows[0].querySelectorAll(
        '[data-test-vulnerability-analysis-cell]'
      );

      const analyses = this.file.analyses
        .toArray()
        .sort((a, b) => b.computedRisk - a.computedRisk); // sort by computedRisk:desc

      const { label } = analysisRiskStatus([
        String(analyses[0].computedRisk),
        String(analyses[0].status),
        analyses[0].isOverriddenRisk,
      ]);

      assert
        .dom('[data-test-analysisRiskTag-label]', firstRowCells[0])
        .hasText(label);

      assert
        .dom(firstRowCells[1])
        .hasText(analyses[0].vulnerability.get('name'));

      const types = analyses[0].vulnerabilityTypes;

      types.forEach((t, i) => {
        assert
          .dom(
            firstRowCells[2].querySelectorAll(
              '[data-test-vulnerability-analysis-scanTypeTag]'
            )[i]
          )
          .hasText(`t:${vulnerabilityTypeTextMap[t]}:()`);
      });
    });

    test.each(
      'test vulnerability analysis filter by vulnerability type',
      [true, false],
      async function (assert, isManualScanAvailable) {
        this.server.get('/v2/projects/:id', (schema, req) => {
          const json = schema.projects.find(`${req.params.id}`)?.toJSON();

          return { ...json, is_manual_scan_available: isManualScanAvailable };
        });

        this.server.get('/hudson-api/projects', () => {
          return new Response(200);
        });

        await render(hbs`
            <FileDetails::VulnerabilityAnalysis @file={{this.file}} />
        `);

        assert
          .dom('[data-test-vulnerability-analysis-title]')
          .hasText('t:vulnerabilityDetails:()');

        assert.dom('[data-test-vulnerability-analysis-filterSelect]').exists();

        // open
        await click(
          `[data-test-vulnerability-analysis-filterSelect] .${classes.trigger}`
        );

        const selectListItems = findAll('.ember-power-select-option');

        assert.dom(selectListItems[0]).hasAria('selected', 'true');

        // close
        await click(
          `[data-test-vulnerability-analysis-filterSelect] .${classes.trigger}`
        );

        let rows = findAll('[data-test-vulnerability-analysis-row]');

        assert.strictEqual(rows.length, this.file.analyses.length);

        const analyses = this.file.analyses
          .toArray()
          .sort((a, b) => b.computedRisk - a.computedRisk); // sort by computedRisk:desc

        const options = [
          { label: 't:static:()', value: 1 },
          { label: 't:dynamic:()', value: 2 },
          isManualScanAvailable && { label: 't:manual:()', value: 3 },
          { label: 't:api:()', value: 4 },
          { label: 't:allScans:()', value: -1 },
        ].filter(Boolean);

        for (let i = 0; i < options.length; i++) {
          const { label, value } = options[i];

          await selectChoose(
            `[data-test-vulnerability-analysis-filterSelect]`,
            label
          );

          rows = findAll('[data-test-vulnerability-analysis-row]');

          assert.strictEqual(
            rows.length,
            value === -1
              ? analyses.length
              : analyses.filter((a) => a.hasType(value)).length
          );
        }
      }
    );

    test('it renders file-details/vulnerability-analysis with edit analysis link', async function (assert) {
      this.server.get('/v2/projects/:id', (schema, req) => {
        return schema.projects.find(`${req.params.id}`)?.toJSON();
      });

      this.server.get('/hudson-api/projects', () => {
        return new Response(200);
      });

      await render(hbs`
        <FileDetails::VulnerabilityAnalysis @file={{this.file}} />
    `);

      assert
        .dom('[data-test-vulnerability-analysis-title]')
        .hasText('t:vulnerabilityDetails:()');

      assert
        .dom('[data-test-vulnerability-analysis-editAnalysesLink]')
        .hasText('t:editAnalyses:()');
    });

    test('test analysis row click', async function (assert) {
      this.server.get('/v2/projects/:id', (schema, req) => {
        return schema.projects.find(`${req.params.id}`)?.toJSON();
      });

      this.server.get('/hudson-api/projects', () => {
        return new Response(200);
      });

      await render(hbs`
        <FileDetails::VulnerabilityAnalysis @file={{this.file}} />
    `);

      assert
        .dom('[data-test-vulnerability-analysis-title]')
        .hasText('t:vulnerabilityDetails:()');

      const rows = findAll('[data-test-vulnerability-analysis-row]');

      await click(rows[1]);

      const analyses = this.file.analyses
        .toArray()
        .sort((a, b) => b.computedRisk - a.computedRisk); // sort by computedRisk:desc

      const router = this.owner.lookup('service:router');
      const transitionToArgs = router.transitionToArgs;

      assert.true(transitionToArgs.length > 0);
      assert.strictEqual(
        transitionToArgs[0],
        'authenticated.dashboard.file.analysis'
      );
      assert.strictEqual(transitionToArgs[1], this.file.id);
      assert.strictEqual(transitionToArgs[2], analyses[1].id);
    });

    test('test analysis sort by impact', async function (assert) {
      this.server.get('/v2/projects/:id', (schema, req) => {
        return schema.projects.find(`${req.params.id}`)?.toJSON();
      });

      this.server.get('/hudson-api/projects', () => {
        return new Response(200);
      });

      await render(hbs`
        <FileDetails::VulnerabilityAnalysis @file={{this.file}} />
    `);

      assert
        .dom('[data-test-vulnerability-analysis-title]')
        .hasText('t:vulnerabilityDetails:()');

      let analyses = this.file.analyses
        .toArray()
        .sort((a, b) => b.computedRisk - a.computedRisk); // sort by computedRisk:desc

      const headerCells = findAll(
        '[data-test-vulnerability-analysis-thead] th'
      );

      assert.strictEqual(headerCells.length, 3);

      let rows = findAll('[data-test-vulnerability-analysis-row]');

      assert.strictEqual(rows.length, this.file.analyses.length);

      // extract row assertions
      const assertRowValues = (row, analysis) => {
        const rowCells = row.querySelectorAll(
          '[data-test-vulnerability-analysis-cell]'
        );

        const { label } = analysisRiskStatus([
          String(analysis.computedRisk),
          String(analysis.status),
          analysis.isOverriddenRisk,
        ]);

        assert
          .dom('[data-test-analysisRiskTag-label]', rowCells[0])
          .hasText(label);

        assert.dom(rowCells[1]).hasText(analysis.vulnerability.get('name'));

        const types = analysis.vulnerabilityTypes;

        types.forEach((t, i) => {
          assert
            .dom(
              rowCells[2].querySelectorAll(
                '[data-test-vulnerability-analysis-scanTypeTag]'
              )[i]
            )
            .hasText(`t:${vulnerabilityTypeTextMap[t]}:()`);
        });
      };

      // assert first & second row
      assertRowValues(rows[0], analyses[0]);
      assertRowValues(rows[1], analyses[1]);

      // click on header to trigger sort
      await click(headerCells[0]);

      analyses = this.file.analyses
        .toArray()
        .sort((a, b) => a.computedRisk - b.computedRisk); // sort by computedRisk:asc

      rows = findAll('[data-test-vulnerability-analysis-row]');

      // again assert first & second row
      assertRowValues(rows[0], analyses[0]);
      assertRowValues(rows[1], analyses[1]);
    });
  }
);
