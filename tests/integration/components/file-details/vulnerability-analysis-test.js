import { click, findAll, render } from '@ember/test-helpers';
import { hbs } from 'ember-cli-htmlbars';
import { setupMirage } from 'ember-cli-mirage/test-support';
import { setupIntl, t } from 'ember-intl/test-support';
import { setupRenderingTest } from 'ember-qunit';
import { module, test } from 'qunit';
import styles from 'irene/components/ak-select/index.scss';
import { selectChoose } from 'ember-power-select/test-support';
import { faker } from '@faker-js/faker';

import { Response } from 'miragejs';
import Service from '@ember/service';

import ENUMS from 'irene/enums';
import { analysisRiskStatus } from 'irene/helpers/analysis-risk-status';
import { compareInnerHTMLWithIntlTranslation } from 'irene/tests/test-utils';
import { setupFileModelEndpoints } from 'irene/tests/helpers/file-model-utils';

class NotificationsStub extends Service {
  errorMsg = null;
  successMsg = null;

  error(msg) {
    this.errorMsg = msg;
  }
  success(msg) {
    this.successMsg = msg;
  }
}

const vulnerabilityTypeTextMap = {
  [ENUMS.VULNERABILITY_TYPE.STATIC]: 'static',
  [ENUMS.VULNERABILITY_TYPE.DYNAMIC]: 'dynamic',
  [ENUMS.VULNERABILITY_TYPE.MANUAL]: 'manual',
  [ENUMS.VULNERABILITY_TYPE.API]: 'api',
};

const classes = {
  dropdown: styles['ak-select-dropdown'],
  trigger: styles['ak-select-trigger'],
  triggerError: styles['ak-select-trigger-error'],
};

module(
  'Integration | Component | file-details/vulnerability-analysis',
  function (hooks) {
    setupRenderingTest(hooks);
    setupMirage(hooks);
    setupIntl(hooks, 'en');

    hooks.beforeEach(async function () {
      setupFileModelEndpoints(this.server);

      const organization = this.server.createList('organization', 1);
      const currentOrganizationMe = this.server.create('organization-me', {
        id: organization.id,
      });

      const store = this.owner.lookup('service:store');

      //   create and push to store
      const vulnerabilities = this.server.createList('vulnerability', 7).reduce(
        (acc, curr) => [
          ...acc,
          store.push(
            store.normalize('vulnerability', {
              attributes: curr.toJSON(),
              id: curr.id,
              relationships: {},
              type: 'vulnerabilities',
            })
          ),
        ],
        []
      );

      const file = this.server.create('file', { project: '1' });
      this.server.create('project', { last_file: file, id: '1' });

      // Create analyses for each vulnerability and map to the file
      const analyses = vulnerabilities.map((v) => {
        const analysis = this.server.create('analysis', {
          vulnerability: v.id,
          file: file.id,
          status: ENUMS.ANALYSIS_STATUS.COMPLETED,
        });

        const normalizedAnalysis = store.normalize(
          'analysis',
          analysis.toJSON()
        );

        return store.push(normalizedAnalysis);
      });

      // Server Mocks
      this.server.get('/organizations/:id/me', (schema, req) =>
        schema.organizationMes.find(`${req.params.id}`)?.toJSON()
      );

      this.setProperties({
        file: store.push(store.normalize('file', file.toJSON())),
        vulnerabilities,
        analyses,
        store,
        currentOrganizationMe,
      });

      await this.owner.lookup('service:organization').load();
      this.owner.register('service:notifications', NotificationsStub);
    });

    test('it renders file-details/vulnerability-analysis', async function (assert) {
      this.server.get('/v3/projects/:id', (schema, req) => {
        return schema.projects.find(`${req.params.id}`)?.toJSON();
      });

      this.server.get('/hudson-api/projects', () => {
        return new Response(403);
      });

      await render(hbs`
        <FileDetails::VulnerabilityAnalysis @file={{this.file}} />
      `);

      assert
        .dom('[data-test-vulnerability-analysis-title]')
        .hasText(t('vulnerabilityDetails'));

      assert
        .dom('[data-test-vulnerability-analysis-description]')
        .hasText(t('fileVulnerabilityDetailsDescription'));

      assert
        .dom('[data-test-vulnerability-analysis-editAnalysesLink]')
        .doesNotExist();

      assert.dom('[data-test-vulnerability-analysis-filterSelect]').exists();

      assert.dom('[data-test-vulnerability-analysis-table]').exists();

      const headerCells = findAll(
        '[data-test-vulnerability-analysis-thead] th'
      );

      assert.strictEqual(headerCells.length, 3);

      assert.dom(headerCells[0]).hasText(t('impact'));
      assert.dom(headerCells[1]).hasText(t('title'));
      assert.dom(headerCells[2]).hasText(t('typeOfScan'));

      const rows = findAll('[data-test-vulnerability-analysis-row]');

      assert.strictEqual(rows.length, this.analyses.length);

      // assert first row
      const firstRowCells = rows[0].querySelectorAll(
        '[data-test-vulnerability-analysis-cell]'
      );

      const analyses = this.analyses
        .toArray()
        .sort((a, b) => b.computedRisk - a.computedRisk); // sort by computedRisk:desc

      const { label } = analysisRiskStatus([
        String(analyses[0].computedRisk),
        String(analyses[0].status),
        analyses[0].isOverriddenRisk,
      ]);

      assert
        .dom('[data-test-analysisRiskTag-label]', firstRowCells[0])
        .hasText(label);

      assert
        .dom(firstRowCells[1])
        .hasText(analyses[0].vulnerability.get('name'));

      const types = analyses[0].vulnerabilityTypes;

      types.forEach((type, i) => {
        assert
          .dom(
            firstRowCells[2].querySelectorAll(
              '[data-test-vulnerability-analysis-scanTypeTag]'
            )[i]
          )
          .hasText(t(vulnerabilityTypeTextMap[type]));
      });
    });

    test.each(
      'test vulnerability analysis filter by vulnerability type',
      [true, false],
      async function (assert, isManualScanAvailable) {
        this.server.get('/v3/projects/:id', (schema, req) => {
          const json = schema.projects.find(`${req.params.id}`)?.toJSON();

          return { ...json, is_manual_scan_available: isManualScanAvailable };
        });

        this.server.get('/hudson-api/projects', () => {
          return new Response(200);
        });

        await render(hbs`
            <FileDetails::VulnerabilityAnalysis @file={{this.file}} />
        `);

        assert
          .dom('[data-test-vulnerability-analysis-title]')
          .hasText(t('vulnerabilityDetails'));

        assert.dom('[data-test-vulnerability-analysis-filterSelect]').exists();

        // open
        await click(
          `[data-test-vulnerability-analysis-filterSelect] .${classes.trigger}`
        );

        const selectListItems = findAll('.ember-power-select-option');

        assert.dom(selectListItems[0]).hasAria('selected', 'true');

        // close
        await click(
          `[data-test-vulnerability-analysis-filterSelect] .${classes.trigger}`
        );

        let rows = findAll('[data-test-vulnerability-analysis-row]');

        assert.strictEqual(rows.length, this.analyses.length);

        const analyses = this.analyses.sort(
          (a, b) => b.computedRisk - a.computedRisk
        ); // sort by computedRisk:desc

        const options = [
          { label: t('static'), value: 1 },
          { label: t('dynamic'), value: 2 },
          isManualScanAvailable && { label: t('manual'), value: 3 },
          { label: t('api'), value: 4 },
          { label: t('allScans'), value: -1 },
        ].filter(Boolean);

        for (let i = 0; i < options.length; i++) {
          const { label, value } = options[i];

          await selectChoose(
            `[data-test-vulnerability-analysis-filterSelect]`,
            label
          );

          rows = findAll('[data-test-vulnerability-analysis-row]');

          assert.strictEqual(
            rows.length,
            value === -1
              ? analyses.length
              : analyses.filter((a) => a.hasType(value)).length
          );
        }
      }
    );

    test('it renders file-details/vulnerability-analysis with edit analysis link', async function (assert) {
      // Set security permission to true to show the edit analysis link
      this.currentOrganizationMe.update({
        has_security_permission: true,
      });

      this.server.get('/v3/projects/:id', (schema, req) => {
        return schema.projects.find(`${req.params.id}`)?.toJSON();
      });

      await render(hbs`
        <FileDetails::VulnerabilityAnalysis @file={{this.file}} />
    `);

      assert
        .dom('[data-test-vulnerability-analysis-title]')
        .hasText(t('vulnerabilityDetails'));

      assert
        .dom('[data-test-vulnerability-analysis-editAnalysesLink]')
        .hasText(t('editAnalyses'));
    });

    test('test analysis sort by impact', async function (assert) {
      // make sure length is same as analyses & vulnerabities
      const ascOrder = [
        ENUMS.RISK.UNKNOWN, // Not started
        ENUMS.RISK.NONE, // Passed
        [ENUMS.RISK.MEDIUM, ENUMS.RISK.NONE], // Passed overridden
        ENUMS.RISK.LOW,
        ENUMS.RISK.MEDIUM,
        ENUMS.RISK.HIGH,
        ENUMS.RISK.CRITICAL,
      ];

      const descOrder = ascOrder.slice().reverse();
      const shuffledOrder = faker.helpers.shuffle(ascOrder);

      this.server.get('/v3/files/:id/analyses', (schema, req) => {
        const analyses = schema.analyses
          .where({ file: req.params.id })
          .models.map((a, idx) => {
            const val = shuffledOrder[idx];
            const isValArray = Array.isArray(val);

            a.risk = isValArray ? val[0] : val;
            a.overridden_risk = isValArray ? val[1] : null;
            a.computed_risk = isValArray ? val[1] : val;

            return a;
          });

        return {
          count: analyses.length,
          next: null,
          previous: null,
          results: analyses,
        };
      });

      this.server.get('/v3/projects/:id', (schema, req) => {
        return schema.projects.find(`${req.params.id}`)?.toJSON();
      });

      this.server.get('/hudson-api/projects', () => {
        return new Response(200);
      });

      await render(hbs`
        <FileDetails::VulnerabilityAnalysis @file={{this.file}} />
      `);

      assert
        .dom('[data-test-vulnerability-analysis-title]')
        .hasText(t('vulnerabilityDetails'));

      const headerCells = findAll(
        '[data-test-vulnerability-analysis-thead] th'
      );

      assert.strictEqual(headerCells.length, 3);

      let rows = findAll('[data-test-vulnerability-analysis-row]');
      assert.strictEqual(rows.length, this.analyses.length);

      // extract row assertions
      const assertRowValues = (row, values) => {
        const rowCells = row.querySelectorAll(
          '[data-test-vulnerability-analysis-cell]'
        );

        const { label } = analysisRiskStatus([
          String(values.computedRisk),
          String(values.status),
          values.isOverriddenRisk,
        ]);

        assert
          .dom('[data-test-analysisRiskTag-label]', rowCells[0])
          .hasText(label);
      };

      // initial sort order in UI is desc
      descOrder.forEach((it, idx) => {
        const isOverridden = Array.isArray(it);

        assertRowValues(rows[idx], {
          computedRisk: isOverridden ? it[1] : it,
          status: ENUMS.ANALYSIS.COMPLETED,
          isOverriddenRisk: isOverridden,
        });
      });

      // click on header to trigger sort
      await click(headerCells[0]);

      rows = findAll('[data-test-vulnerability-analysis-row]');

      // again assert for asc order
      ascOrder.forEach((it, idx) => {
        const isOverridden = Array.isArray(it);

        assertRowValues(rows[idx], {
          computedRisk: isOverridden ? it[1] : it,
          status: ENUMS.ANALYSIS.COMPLETED,
          isOverriddenRisk: isOverridden,
        });
      });
    });

    test('it renders emtpy file-details/vulnerability-analysis', async function (assert) {
      assert.expect(8);

      this.server.get('/v3/projects/:id', (schema, req) => {
        return schema.projects.find(`${req.params.id}`)?.toJSON();
      });

      this.server.get('/hudson-api/projects', () => {
        return new Response(403);
      });

      // File Analyses
      this.server.get('/v3/files/:id/analyses', () => {
        return {
          count: 0,
          next: null,
          previous: null,
          results: [],
        };
      });

      await render(hbs`
        <FileDetails::VulnerabilityAnalysis @file={{this.file}} />
      `);

      assert
        .dom('[data-test-vulnerability-analysis-title]')
        .hasText(t('vulnerabilityDetails'));

      assert
        .dom('[data-test-vulnerability-analysis-description]')
        .hasText(t('fileVulnerabilityDetailsDescription'));

      assert
        .dom('[data-test-vulnerability-analysis-editAnalysesLink]')
        .doesNotExist();

      assert.dom('[data-test-vulnerability-analysis-filterSelect]').exists();

      assert.dom('[data-test-vulnerability-analysis-table]').doesNotExist();

      assert.dom('[data-test-vulnerability-analysis-emptySvg]').exists();

      assert
        .dom('[data-test-vulnerability-analysis-emptyTitle]')
        .hasText(t('fileVulnerabilityEmpty.title'));

      compareInnerHTMLWithIntlTranslation(assert, {
        selector: '[data-test-vulnerability-analysis-emptyDesc1]',
        message: t('fileVulnerabilityEmpty.description'),
      });
    });

    test('it shows emtpy ui when no test case for selected vulnerability type is there', async function (assert) {
      assert.expect(14);

      this.vulnerabilities.forEach((v) => {
        const t = ENUMS.VULNERABILITY_TYPE;

        v.types = faker.helpers.arrayElements([t.STATIC, t.DYNAMIC]);
      });

      this.server.get('/v3/projects/:id', (schema, req) => {
        return schema.projects.find(`${req.params.id}`)?.toJSON();
      });

      this.server.get('/hudson-api/projects', () => {
        return new Response(403);
      });

      await render(hbs`
        <FileDetails::VulnerabilityAnalysis @file={{this.file}} />
      `);

      assert
        .dom('[data-test-vulnerability-analysis-title]')
        .hasText(t('vulnerabilityDetails'));

      assert
        .dom('[data-test-vulnerability-analysis-description]')
        .hasText(t('fileVulnerabilityDetailsDescription'));

      assert
        .dom('[data-test-vulnerability-analysis-editAnalysesLink]')
        .doesNotExist();

      assert.dom('[data-test-vulnerability-analysis-filterSelect]').exists();

      assert.dom('[data-test-vulnerability-analysis-table]').exists();

      const headerCells = findAll(
        '[data-test-vulnerability-analysis-thead] th'
      );

      assert.strictEqual(headerCells.length, 3);

      assert.dom(headerCells[0]).hasText(t('impact'));
      assert.dom(headerCells[1]).hasText(t('title'));
      assert.dom(headerCells[2]).hasText(t('typeOfScan'));

      const rows = findAll('[data-test-vulnerability-analysis-row]');

      assert.strictEqual(rows.length, this.analyses.length);

      // api type test case not present
      await selectChoose(
        `[data-test-vulnerability-analysis-filterSelect]`,
        t('api')
      );

      assert.dom('[data-test-vulnerability-analysis-table]').doesNotExist();

      assert.dom('[data-test-vulnerability-analysis-emptySvg]').exists();

      assert
        .dom('[data-test-vulnerability-analysis-emptyTitle]')
        .hasText(t('fileVulnerabilityEmpty.title'));

      compareInnerHTMLWithIntlTranslation(assert, {
        selector: '[data-test-vulnerability-analysis-emptyDesc1]',
        message: t('fileVulnerabilityEmpty.description'),
      });
    });
  }
);
