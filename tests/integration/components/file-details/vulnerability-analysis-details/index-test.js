import { click, find, render } from '@ember/test-helpers';
import { hbs } from 'ember-cli-htmlbars';
import { setupMirage } from 'ember-cli-mirage/test-support';
import { setupIntl } from 'ember-intl/test-support';
import { setupRenderingTest } from 'ember-qunit';
import ENUMS from 'irene/enums';
import { module, test } from 'qunit';
import Service from '@ember/service';

import { analysisRiskStatus } from 'irene/helpers/analysis-risk-status';

const serializeForJsonApi = (payload, type) => ({
  data: {
    attributes: payload,
    id: payload.id,
    type,
  },
});

const vulnerabilityTypeTextMap = {
  [ENUMS.VULNERABILITY_TYPE.STATIC]: 'static',
  [ENUMS.VULNERABILITY_TYPE.DYNAMIC]: 'dynamic',
  [ENUMS.VULNERABILITY_TYPE.MANUAL]: 'manual',
  [ENUMS.VULNERABILITY_TYPE.API]: 'api',
};

class WindowStub extends Service {
  url = null;
  target = null;

  open(url, target) {
    this.url = url;
    this.target = target;
  }
}

module(
  'Integration | Component | vulnerability-analysis-details',
  function (hooks) {
    setupRenderingTest(hooks);
    setupMirage(hooks);
    setupIntl(hooks);

    hooks.beforeEach(async function () {
      this.server.createList('organization', 1);
      this.server.createList('organization-me', 1);

      const store = this.owner.lookup('service:store');

      const profile = this.server.create('profile', { id: '100' });

      const project = this.server.create('project', {
        id: '1',
        is_manual_scan_available: true,
      });

      //   create and push to store
      const vulnerabilities = this.server
        .createList('vulnerability', 3)
        .reduce(
          (acc, curr) => [
            ...acc,
            store.push(
              store.normalize(
                'vulnerability',
                serializeForJsonApi(curr.toJSON(), 'vulnerabilities').data
              )
            ),
          ],
          []
        );

      const analyses = vulnerabilities.map((v, i) =>
        this.server.create(
          'analysis',
          i === vulnerabilities.length - 1 ? null : 'withAllRegulatory',
          {
            vulnerability: v.id,
            file: '1',
            status: ENUMS.ANALYSIS_STATUS.COMPLETED,
          }
        )
      );

      const file = this.server.create('file', {
        project: project.id,
        profile: profile.id,
        analyses: analyses.map((a) => a.toJSON()),
      });

      this.setProperties({
        file: store.push(store.normalize('file', file.toJSON())),
        vulnerabilities,
        store,
      });

      await this.owner.lookup('service:organization').load();
      this.owner.register('service:browser/window', WindowStub);
    });

    this.headerAssertions = (assert, analysis) => {
      const headerSummary = [
        {
          title: 't:impact:()',
          assertValue: (container) => {
            const { label } = analysisRiskStatus([
              String(analysis.computedRisk),
              String(analysis.status),
              analysis.isOverriddenRisk,
            ]);

            assert
              .dom('[data-test-analysisRiskTag-label]', container)
              .hasText(label);
          },
        },
        {
          title: 't:title:()',
          assertValue: (container) => {
            assert
              .dom('[data-test-analysisDetails-headerSummaryValue]', container)
              .hasText(analysis.vulnerability.get('name'));
          },
        },
        {
          title: 't:typeOfScan:()',
          assertValue: (container) => {
            analysis.vulnerabilityTypes.forEach((t, i) => {
              assert
                .dom(
                  container.querySelectorAll(
                    '[data-test-vulnerability-analysis-scanTypeTag]'
                  )[i]
                )
                .hasText(`t:${vulnerabilityTypeTextMap[t]}:()`);
            });
          },
        },
      ];

      headerSummary.forEach((summary) => {
        const container = find(
          `[data-test-analysisDetails-headerSummaryGroup="${summary.title}"]`
        );

        assert
          .dom('[data-test-analysisDetails-headerSummaryTitle]', container)
          .hasText(summary.title);

        summary.assertValue(container);
      });
    };

    // eslint-disable-next-line qunit/require-expect
    test('it renders analysis details header', async function (assert) {
      this.set('analysis', this.file.analyses.toArray()[0]);

      this.server.get('/organizations/:id/me', (schema, req) =>
        schema.organizationMes.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/profiles/:id', (schema, req) =>
        schema.profiles.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/owasps/:id', (schema, req) =>
        serializeForJsonApi(
          schema.owasps.find(`${req.params.id}`)?.toJSON(),
          'owasps'
        )
      );

      this.server.get('/v2/owaspmobile2024s/:id', (schema, req) =>
        schema.owaspmobile2024s.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/owaspapi2023s/:id', (schema, req) =>
        schema.owaspapi2023s.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/cwes/:id', (schema, req) =>
        schema.cwes.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/asvses/:id', (schema, req) =>
        schema.asvses.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/masvses/:id', (schema, req) =>
        schema.masvses.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/mstgs/:id', (schema, req) =>
        schema.mstgs.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/pcidsses/:id', (schema, req) =>
        serializeForJsonApi(
          schema.pcidsses.find(`${req.params.id}`)?.toJSON(),
          'pcidsses'
        )
      );

      this.server.get('/v2/gdprs/:id', (schema, req) =>
        schema.gdprs.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/hipaas/:id', (schema, req) =>
        schema.hipaas.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/nistsp80053s/:id', (schema, req) =>
        schema.nistsp80053s.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/nistsp800171s/:id', (schema, req) =>
        schema.nistsp800171s.find(`${req.params.id}`)?.toJSON()
      );

      await render(
        hbs`<FileDetails::VulnerabilityAnalysisDetails @analysis={{this.analysis}} @showHeader={{true}} />`
      );

      assert.dom('[data-test-analysisDetails-header]').exists();

      this.headerAssertions(assert, this.analysis);
    });

    test.each(
      'it renders analysis details description',
      [ENUMS.RISK.MEDIUM, ENUMS.RISK.NONE, ENUMS.RISK.UNKNOWN],
      async function (assert, computedRisk) {
        const analysis = this.file.analyses.lastObject;
        analysis.computedRisk = computedRisk;

        this.set('analysis', analysis);

        this.server.get('/organizations/:id/me', (schema, req) =>
          schema.organizationMes.find(`${req.params.id}`)?.toJSON()
        );

        this.server.get('/profiles/:id', (schema, req) =>
          schema.profiles.find(`${req.params.id}`)?.toJSON()
        );

        await render(
          hbs`<FileDetails::VulnerabilityAnalysisDetails @analysis={{this.analysis}} @showHeader={{true}} />`
        );

        assert.dom('[data-test-analysisDetails-header]').exists();

        assert
          .dom('[data-test-analysisDetails-descriptionLabel]')
          .hasText('t:description:()');

        if (analysis.isScanning) {
          assert
            .dom('[data-test-analysisDetails-descriptionValue]')
            .hasText(analysis.vulnerability.get('question'));
        } else if (analysis.isRisky) {
          assert
            .dom('[data-test-analysisDetails-descriptionValue]')
            .hasText(
              analysis.vulnerability.get('descriptionUnescapedd').toString()
            );
        } else {
          assert
            .dom('[data-test-analysisDetails-descriptionValue]')
            .hasText(analysis.vulnerability.get('successMessage'));
        }
      }
    );

    const businessImplication = 'Cum est qui quo fugiat hic sit unde';

    test.each(
      'it renders analysis details bussiness implication',
      [
        [ENUMS.RISK.MEDIUM, businessImplication],
        [ENUMS.RISK.MEDIUM, ''],
        [ENUMS.RISK.NONE, businessImplication],
        [ENUMS.RISK.UNKNOWN, businessImplication],
      ],
      async function (assert, [computedRisk, businessImplication]) {
        const analysis = this.file.analyses.lastObject;
        analysis.computedRisk = computedRisk;

        analysis.vulnerability.set('businessImplication', businessImplication);

        this.set('analysis', analysis);

        this.server.get('/organizations/:id/me', (schema, req) =>
          schema.organizationMes.find(`${req.params.id}`)?.toJSON()
        );

        this.server.get('/profiles/:id', (schema, req) =>
          schema.profiles.find(`${req.params.id}`)?.toJSON()
        );

        await render(
          hbs`<FileDetails::VulnerabilityAnalysisDetails @analysis={{this.analysis}} @showHeader={{true}} />`
        );

        assert.dom('[data-test-analysisDetails-header]').exists();

        if (
          analysis.isRisky &&
          analysis.vulnerability.get('businessImplication')
        ) {
          assert
            .dom('[data-test-analysisDetails-bussinessImpLabel]')
            .hasText('t:businessImplication:()');

          assert
            .dom('[data-test-analysisDetails-bussinessImpValue]')
            .hasText(analysis.vulnerability.get('businessImplication'));
        } else {
          assert
            .dom('[data-test-analysisDetails-bussinessImpLabel]')
            .doesNotExist();

          assert
            .dom('[data-test-analysisDetails-bussinessImpValue]')
            .doesNotExist();
        }
      }
    );

    const compliantSolution = 'Cum est qui quo fugiat hic sit unde';

    test.each(
      'it renders analysis details compliant solution',
      [
        [ENUMS.RISK.MEDIUM, compliantSolution],
        [ENUMS.RISK.MEDIUM, ''],
        [ENUMS.RISK.NONE, compliantSolution],
        [ENUMS.RISK.UNKNOWN, compliantSolution],
      ],
      async function (assert, [computedRisk, compliantSolution]) {
        const analysis = this.file.analyses.lastObject;
        analysis.computedRisk = computedRisk;

        analysis.vulnerability.set('compliant', compliantSolution);

        this.set('analysis', analysis);

        this.server.get('/organizations/:id/me', (schema, req) =>
          schema.organizationMes.find(`${req.params.id}`)?.toJSON()
        );

        this.server.get('/profiles/:id', (schema, req) =>
          schema.profiles.find(`${req.params.id}`)?.toJSON()
        );

        await render(
          hbs`<FileDetails::VulnerabilityAnalysisDetails @analysis={{this.analysis}} @showHeader={{true}} />`
        );

        assert.dom('[data-test-analysisDetails-header]').exists();

        if (analysis.isRisky && analysis.vulnerability.get('compliant')) {
          assert
            .dom('[data-test-analysisDetails-compliantLabel]')
            .hasText('t:compliantSolution:()');

          assert
            .dom('[data-test-analysisDetails-compliantValue]')
            .hasText(analysis.vulnerability.get('compliant'));
        } else {
          assert
            .dom('[data-test-analysisDetails-compliantLabel]')
            .doesNotExist();

          assert
            .dom('[data-test-analysisDetails-compliantValue]')
            .doesNotExist();
        }
      }
    );

    const nonCompliantCodeExample = 'Cum est qui quo fugiat hic sit unde';

    test.each(
      'it renders analysis details non compliant solution',
      [
        [ENUMS.RISK.MEDIUM, nonCompliantCodeExample],
        [ENUMS.RISK.MEDIUM, ''],
        [ENUMS.RISK.NONE, nonCompliantCodeExample],
        [ENUMS.RISK.UNKNOWN, nonCompliantCodeExample],
      ],
      async function (assert, [computedRisk, nonCompliantCodeExample]) {
        const analysis = this.file.analyses.lastObject;
        analysis.computedRisk = computedRisk;

        analysis.vulnerability.set('nonCompliant', nonCompliantCodeExample);

        this.set('analysis', analysis);

        this.server.get('/organizations/:id/me', (schema, req) =>
          schema.organizationMes.find(`${req.params.id}`)?.toJSON()
        );

        this.server.get('/profiles/:id', (schema, req) =>
          schema.profiles.find(`${req.params.id}`)?.toJSON()
        );

        await render(
          hbs`<FileDetails::VulnerabilityAnalysisDetails @analysis={{this.analysis}} @showHeader={{true}} />`
        );

        assert.dom('[data-test-analysisDetails-header]').exists();

        if (analysis.isRisky && analysis.vulnerability.get('nonCompliant')) {
          assert
            .dom('[data-test-analysisDetails-nonCompliantLabel]')
            .hasText('t:nonCompliantCodeExample:()');

          assert
            .dom('[data-test-analysisDetails-nonCompliantValue]')
            .hasText(analysis.vulnerability.get('nonCompliant'));
        } else {
          assert
            .dom('[data-test-analysisDetails-nonCompliantLabel]')
            .doesNotExist();

          assert
            .dom('[data-test-analysisDetails-nonCompliantValue]')
            .doesNotExist();
        }
      }
    );

    test.each(
      'it renders analysis details with vulnerabilities',
      [ENUMS.RISK.MEDIUM, ENUMS.RISK.NONE, ENUMS.RISK.UNKNOWN],
      async function (assert, computedRisk) {
        const analysis = this.file.analyses.lastObject;
        analysis.computedRisk = computedRisk;

        this.set('analysis', analysis);

        this.server.get('/organizations/:id/me', (schema, req) =>
          schema.organizationMes.find(`${req.params.id}`)?.toJSON()
        );

        this.server.get('/profiles/:id', (schema, req) =>
          schema.profiles.find(`${req.params.id}`)?.toJSON()
        );

        await render(
          hbs`<FileDetails::VulnerabilityAnalysisDetails @analysis={{this.analysis}} @showHeader={{true}} />`
        );

        assert.dom('[data-test-analysisDetails-header]').exists();

        if (analysis.isRisky) {
          assert
            .dom('[data-test-analysisDetails-vulnerabilityTitle]')
            .hasText('t:vulnerability:()');

          analysis.findings.forEach((f, i) => {
            if (f.title) {
              assert
                .dom(`[data-test-analysisDetails-vulFindingTitle="${i}"]`)
                .hasText(f.title);
            }

            assert
              .dom(`[data-test-analysisDetails-vulFindingDescription="${i}"]`)
              .hasText(f.description);
          });
        } else {
          assert
            .dom('[data-test-analysisDetails-vulnerabilityContainer]')
            .doesNotExist();
        }
      }
    );

    test('it renders analysis details with attachments', async function (assert) {
      const attachments = this.server.createList('attachment', 3);

      const vulnerability = this.store.push(
        this.store.normalize(
          'vulnerability',
          serializeForJsonApi(
            this.server.create('vulnerability').toJSON(),
            'vulnerabilities'
          ).data
        )
      );

      this.store.push(
        this.store.normalize(
          'analysis',
          this.server
            .create('analysis', {
              vulnerability: vulnerability.id,
              file: '1',
              attachments: attachments.map((a) => a.toJSON()),
              status: ENUMS.ANALYSIS_STATUS.COMPLETED,
            })
            .toJSON()
        )
      );

      const analysis = this.file.analyses.lastObject;

      this.set('analysis', analysis);

      this.server.get('/organizations/:id/me', (schema, req) =>
        schema.organizationMes.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/profiles/:id', (schema, req) =>
        schema.profiles.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/dummy_attachment_download_url/:id', () => ({
        data: { url: 'some_attachment_download_url.com' },
      }));

      await render(
        hbs`<FileDetails::VulnerabilityAnalysisDetails @analysis={{this.analysis}} @showHeader={{true}} />`
      );

      assert.dom('[data-test-analysisDetails-header]').exists();

      assert
        .dom('[data-test-analysisDetails-attachmentsTitle]')
        .hasText('t:attachments:()');

      attachments.forEach((a) => {
        assert
          .dom(`[data-test-attachmentDetail-btn="${a.uuid}"]`)
          .hasText(`${a.uuid}_${a.name}`);
      });

      // test download
      await click(`[data-test-attachmentDetail-btn="${attachments[0].uuid}"]`);

      const window = this.owner.lookup('service:browser/window');

      assert.strictEqual(window.url, 'some_attachment_download_url.com');
    });

    test.each(
      'it does not render regulatories for (passed, untested) risk',
      [ENUMS.RISK.NONE, ENUMS.RISK.UNKNOWN],
      async function (assert, computedRisk) {
        const analysis = this.file.analyses.firstObject;
        analysis.computedRisk = computedRisk;

        this.set('analysis', analysis);

        this.server.get('/organizations/:id/me', (schema, req) =>
          schema.organizationMes.find(`${req.params.id}`)?.toJSON()
        );

        await render(
          hbs`<FileDetails::VulnerabilityAnalysisDetails @analysis={{this.analysis}} @showHeader={{true}} />`
        );

        assert.dom('[data-test-analysisDetails-header]').exists();

        this.headerAssertions(assert, this.analysis);

        assert
          .dom('[data-test-analysisDetails-regulatory="cvssv3"]')
          .doesNotExist();

        assert
          .dom('[data-test-analysisDetails-regulatory="owasp"]')
          .doesNotExist();

        assert
          .dom('[data-test-analysisDetails-regulatory="owaspmobile2024"]')
          .doesNotExist();

        assert
          .dom('[data-test-analysisDetails-regulatory="owaspapi2023"]')
          .doesNotExist();

        assert
          .dom('[data-test-analysisDetails-regulatory="cwe"]')
          .doesNotExist();

        assert
          .dom('[data-test-analysisDetails-regulatory="asvs"]')
          .doesNotExist();

        assert
          .dom('[data-test-analysisDetails-regulatory="masvs"]')
          .doesNotExist();

        assert
          .dom('[data-test-analysisDetails-regulatory="mstg"]')
          .doesNotExist();
      }
    );

    test.each(
      'it does not render regulatories if analysis is not completed',
      [ENUMS.ANALYSIS.WAITING, ENUMS.ANALYSIS.RUNNING, ENUMS.ANALYSIS.ERROR],
      async function (assert, status) {
        const analysis = this.file.analyses.firstObject;
        analysis.computedRisk = ENUMS.RISK.UNKNOWN;
        analysis.status = status;

        this.set('analysis', analysis);

        this.server.get('/organizations/:id/me', (schema, req) =>
          schema.organizationMes.find(`${req.params.id}`)?.toJSON()
        );

        await render(
          hbs`<FileDetails::VulnerabilityAnalysisDetails @analysis={{this.analysis}} @showHeader={{true}} />`
        );

        assert.dom('[data-test-analysisDetails-header]').exists();

        this.headerAssertions(assert, this.analysis);

        assert
          .dom('[data-test-analysisDetails-regulatory="cvssv3"]')
          .doesNotExist();

        assert
          .dom('[data-test-analysisDetails-regulatory="owasp"]')
          .doesNotExist();

        assert
          .dom('[data-test-analysisDetails-regulatory="owaspmobile2024"]')
          .doesNotExist();

        assert
          .dom('[data-test-analysisDetails-regulatory="owaspapi2023"]')
          .doesNotExist();

        assert
          .dom('[data-test-analysisDetails-regulatory="cwe"]')
          .doesNotExist();

        assert
          .dom('[data-test-analysisDetails-regulatory="asvs"]')
          .doesNotExist();

        assert
          .dom('[data-test-analysisDetails-regulatory="masvs"]')
          .doesNotExist();

        assert
          .dom('[data-test-analysisDetails-regulatory="mstg"]')
          .doesNotExist();
      }
    );

    test('it renders common regulatories by default', async function (assert) {
      const analysis = this.file.analyses.firstObject;
      analysis.computedRisk = ENUMS.RISK.CRITICAL;

      this.set('analysis', analysis);

      this.server.get('/organizations/:id/me', (schema, req) =>
        schema.organizationMes.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/profiles/:id', (schema, req) =>
        schema.profiles.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/owasps/:id', (schema, req) =>
        serializeForJsonApi(
          schema.owasps.find(`${req.params.id}`)?.toJSON(),
          'owasps'
        )
      );

      this.server.get('/v2/owaspmobile2024s/:id', (schema, req) =>
        schema.owaspmobile2024s.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/owaspapi2023s/:id', (schema, req) =>
        schema.owaspapi2023s.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/cwes/:id', (schema, req) =>
        schema.cwes.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/asvses/:id', (schema, req) =>
        schema.asvses.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/masvses/:id', (schema, req) =>
        schema.masvses.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/mstgs/:id', (schema, req) =>
        schema.mstgs.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/pcidsses/:id', (schema, req) =>
        serializeForJsonApi(
          schema.pcidsses.find(`${req.params.id}`)?.toJSON(),
          'pcidsses'
        )
      );

      this.server.get('/v2/gdprs/:id', (schema, req) =>
        schema.gdprs.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/hipaas/:id', (schema, req) =>
        schema.hipaas.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('v2/nistsp80053s/:id', (schema, req) =>
        schema.nistsp80053s.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/nistsp800171s/:id', (schema, req) =>
        schema.nistsp800171s.find(`${req.params.id}`)?.toJSON()
      );

      await render(
        hbs`<FileDetails::VulnerabilityAnalysisDetails @analysis={{this.analysis}} @showHeader={{true}} />`
      );

      assert.dom('[data-test-analysisDetails-header]').exists();

      assert.dom('[data-test-analysisDetails-regulatory="cvssv3"]').exists();

      if (
        assert
          .dom('[data-test-analysisDetails-regulatory="owaspmobile2024"]')
          .exists()
      ) {
        assert
          .dom('[data-test-analysisDetails-regulatory="owasp"]')
          .doesNotExist();
      } else {
        assert.dom('[data-test-analysisDetails-regulatory="owasp"]').exists();
      }

      assert
        .dom('[data-test-analysisDetails-regulatory="owaspmobile2024"]')
        .exists();

      assert
        .dom('[data-test-analysisDetails-regulatory="owaspapi2023"]')
        .exists();

      assert.dom('[data-test-analysisDetails-regulatory="cwe"]').exists();
      assert.dom('[data-test-analysisDetails-regulatory="asvs"]').exists();
      assert.dom('[data-test-analysisDetails-regulatory="masvs"]').exists();
      assert.dom('[data-test-analysisDetails-regulatory="mstg"]').exists();
    });

    test('it renders optional regulatories based in profile regulatory preference', async function (assert) {
      const analysis = this.file.analyses.firstObject;
      analysis.computedRisk = ENUMS.RISK.CRITICAL;

      this.set('analysis', analysis);

      this.server.get('/organizations/:id/me', (schema, req) =>
        schema.organizationMes.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/profiles/:id', (schema, req) => {
        const json = schema.profiles.find(`${req.params.id}`)?.toJSON();
        return {
          ...json,
          report_preference: {
            show_pcidss: {
              value: true,
              is_inherited: true,
            },
            show_hipaa: {
              value: false,
              is_inherited: true,
            },
            show_gdpr: {
              value: true,
              is_inherited: false,
            },
            show_nist: {
              value: false,
              is_inherited: false,
            },
          },
        };
      });

      this.server.get('/owasps/:id', (schema, req) =>
        serializeForJsonApi(
          schema.owasps.find(`${req.params.id}`)?.toJSON(),
          'owasps'
        )
      );

      this.server.get('/v2/owaspmobile2024s/:id', (schema, req) =>
        schema.owaspmobile2024s.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/owaspapi2023s/:id', (schema, req) =>
        schema.owaspapi2023s.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/cwes/:id', (schema, req) =>
        schema.cwes.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/asvses/:id', (schema, req) =>
        schema.asvses.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/mstgs/:id', (schema, req) =>
        schema.mstgs.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/masvses/:id', (schema, req) =>
        schema.masvses.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/pcidsses/:id', (schema, req) =>
        serializeForJsonApi(
          schema.pcidsses.find(`${req.params.id}`)?.toJSON(),
          'pcidsses'
        )
      );

      this.server.get('/v2/gdprs/:id', (schema, req) =>
        schema.gdprs.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/hipaas/:id', (schema, req) =>
        schema.hipaas.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('v2/nistsp80053s/:id', (schema, req) =>
        schema.nistsp80053s.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/v2/nistsp800171s/:id', (schema, req) =>
        schema.nistsp800171s.find(`${req.params.id}`)?.toJSON()
      );

      await render(
        hbs`<FileDetails::VulnerabilityAnalysisDetails @analysis={{this.analysis}} @showHeader={{true}} />`
      );

      assert.dom('[data-test-analysisDetails-header]').exists();

      assert.dom('[data-test-analysisDetails-regulatory="pcidss"]').exists();

      assert
        .dom('[data-test-analysisDetails-regulatory="hipaa"]')
        .doesNotExist();

      assert.dom('[data-test-analysisDetails-regulatory="gdpr"]').exists();

      assert
        .dom('[data-test-analysisDetails-regulatory="nistsp80053"]')
        .doesNotExist();

      assert
        .dom('[data-test-analysisDetails-regulatory="nistsp800171"]')
        .doesNotExist();
    });

    test('it renders analysis details cvss3 metrics', async function (assert) {
      const analysis = this.file.analyses.lastObject;
      analysis.computedRisk = ENUMS.RISK.HIGH;

      this.set('analysis', analysis);

      this.server.get('/organizations/:id/me', (schema, req) =>
        schema.organizationMes.find(`${req.params.id}`)?.toJSON()
      );

      this.server.get('/profiles/:id', (schema, req) =>
        schema.profiles.find(`${req.params.id}`)?.toJSON()
      );

      await render(
        hbs`<FileDetails::VulnerabilityAnalysisDetails @analysis={{this.analysis}} @showHeader={{true}} />`
      );

      assert.dom('[data-test-analysisDetails-header]').exists();

      let container = find("[data-test-analysisDetails-regulatory='cvssv3']");

      assert.dom(container).exists();

      assert
        .dom('[data-test-analysisDetails-regulatoryLabel]', container)
        .hasText('t:cvssV3:()');

      assert
        .dom('[data-test-analysisDetails-regulatoryValue]', container)
        .hasText(String(analysis.cvssBase));

      container = find(
        "[data-test-analysisDetails-regulatory='cvssv3metrics']"
      );

      assert.dom(container).exists();

      assert
        .dom('[data-test-analysisDetails-regulatoryLabel]', container)
        .hasText('t:cvssMetrics:()');

      const contents = container.querySelectorAll(
        '[data-test-analysisDetail-regulatoryContent-listItem]'
      );

      contents.forEach((ctnt, i) => {
        assert
          .dom(
            '[data-test-analysisDetail-regulatoryContent-labelContainer]',
            ctnt
          )
          .hasText(analysis.cvssMetricsHumanized[i].key);

        assert
          .dom(
            '[data-test-analysisDetail-regulatoryContent-ValueContainer]',
            ctnt
          )
          .hasText(analysis.cvssMetricsHumanized[i].value);
      });
    });

    test.each(
      'test it renders respective regulatory contents',
      [
        ['withOwasp', 'owasps', 'owasps', 'owasp', null, true],
        [
          'withOwaspMobile2024',
          'v2/owaspmobile2024s',
          'owaspmobile2024s',
          'owaspmobile2024',
          null,
        ],
        [
          'withOwaspApi2023',
          'v2/owaspapi2023s',
          'owaspapi2023s',
          'owaspapi2023',
          null,
        ],
        ['withCwe', 'v2/cwes', 'cwes', 'cwe', 'url'],
        ['withAsvs', 'v2/asvses', 'asvses', 'asvs', null],
        ['withMasvs', 'v2/masvses', 'masvses', 'masvs', null],
        ['withMstg', 'v2/mstgs', 'mstgs', 'mstg', null],
        ['withGdpr', 'v2/gdprs', 'gdprs', 'gdpr', null],
        [
          'withNistsp80053',
          'v2/nistsp80053s',
          'nistsp80053s',
          'nistsp80053',
          null,
        ],
        [
          'withNistsp800171',
          'v2/nistsp800171s',
          'nistsp800171s',
          'nistsp800171',
          null,
        ],
      ],
      async function (
        assert,
        [trait, urlParam, schemaKey, modelKey, valueKey, isJsonApi]
      ) {
        const vulnerability = this.store.push(
          this.store.normalize(
            'vulnerability',
            serializeForJsonApi(
              this.server.create('vulnerability').toJSON(),
              'vulnerabilities'
            ).data
          )
        );

        const analysis = this.store.push(
          this.store.normalize(
            'analysis',
            this.server
              .create('analysis', trait, {
                vulnerability: vulnerability.id,
                file: '1',
                status: ENUMS.ANALYSIS_STATUS.COMPLETED,
                computed_risk: ENUMS.RISK.LOW,
              })
              .toJSON()
          )
        );

        // this.file.analyses.push(analysis);

        this.set('analysis', analysis);

        this.server.get('/organizations/:id/me', (schema, req) =>
          schema.organizationMes.find(`${req.params.id}`)?.toJSON()
        );

        this.server.get(`/${urlParam}/:id`, (schema, req) => {
          const json = schema[schemaKey].find(`${req.params.id}`)?.toJSON();

          return isJsonApi ? serializeForJsonApi(json, schemaKey) : json;
        });

        this.server.get('/profiles/:id', (schema, req) => {
          const json = schema.profiles.find(`${req.params.id}`)?.toJSON();

          return {
            ...json,
            report_preference: {
              ...json.report_preference,
              show_gdpr: {
                value: modelKey === 'gdpr',
                is_inherited: false,
              },
              show_nist: {
                value:
                  modelKey === 'nistsp80053' || modelKey === 'nistsp800171',
                is_inherited: false,
              },
            },
          };
        });

        await render(
          hbs`<FileDetails::VulnerabilityAnalysisDetails @analysis={{this.analysis}} @showHeader={{true}} />`
        );

        assert.dom('[data-test-analysisDetails-header]').exists();

        const container = find(
          `[data-test-analysisDetails-regulatory="${modelKey}"]`
        );

        assert.dom(container).exists();

        assert
          .dom('[data-test-analysisDetails-regulatoryLabel]', container)
          .hasText(`t:${modelKey}:()`);

        const contents = container.querySelectorAll(
          '[data-test-analysisDetail-regulatoryContent-listItem]'
        );

        const regulatorContent = analysis[modelKey].toArray();

        contents.forEach((ctnt, i) => {
          assert
            .dom(
              '[data-test-analysisDetail-regulatoryContent-labelContainer]',
              ctnt
            )
            .hasText(regulatorContent[i].code);

          assert
            .dom(
              '[data-test-analysisDetail-regulatoryContent-ValueContainer]',
              ctnt
            )
            .hasText(regulatorContent[i][valueKey || 'title']);
        });
      }
    );

    test.each(
      'it does not render regulatories if not present or empty',
      [
        ['owasp', []],
        ['owasp'],
        ['owaspmobile2024', []],
        ['owaspmobile2024'],
        ['owaspapi2023', []],
        ['owaspapi2023'],
        ['cwe', []],
        ['cwe'],
        ['asvs', []],
        ['asvs'],
        ['masvs', []],
        ['masvs'],
        ['mstg', []],
        ['mstg'],
        ['gdpr', []],
        ['gdpr'],
        ['pcidss', []],
        ['pcidss'],
        ['hipaa', []],
        ['hipaa'],
        ['nistsp80053', []],
        ['nistsp80053'],
        ['nistsp800171', []],
        ['nistsp800171'],
      ],
      async function (assert, [modelKey, modelValue]) {
        const vulnerability = this.store.push(
          this.store.normalize(
            'vulnerability',
            serializeForJsonApi(
              this.server.create('vulnerability').toJSON(),
              'vulnerabilities'
            ).data
          )
        );

        const analysis = this.store.push(
          this.store.normalize('analysis', {
            ...this.server
              .create('analysis', 'withAllRegulatory', {
                vulnerability: vulnerability.id,
                file: '1',
                status: ENUMS.ANALYSIS_STATUS.COMPLETED,
                computed_risk: ENUMS.RISK.LOW,
              })
              .toJSON(),
            [modelKey]: modelValue,
          })
        );

        this.set('analysis', analysis);

        [
          ['owasps', 'owasps', 'owasp', true],
          ['v2/owaspmobile2024s', 'owaspmobile2024s', 'owaspmobile2024'],
          ['v2/owaspapi2023s', 'owaspapi2023s', 'owaspapi2023'],
          ['v2/cwes', 'cwes', 'cwe'],
          ['v2/asvses', 'asvses', 'asvs'],
          ['v2/masvses', 'masvses', 'masvs'],
          ['v2/mstgs', 'mstgs', 'mstg'],
          ['v2/gdprs', 'gdprs', 'gdpr'],
          ['pcidsses', 'pcidsses', 'pcidss', true],
          ['v2/hipaas', 'hipaas', 'hipaa'],
          ['v2/nistsp80053s', 'nistsp80053s', 'nistsp80053'],
          ['v2/nistsp800171s', 'nistsp800171s', 'nistsp800171'],
        ].forEach(([urlParam, schemaKey, key, isJsonApi]) => {
          if (key !== modelKey) {
            this.server.get(`/${urlParam}/:id`, (schema, req) => {
              const json = schema[schemaKey].find(`${req.params.id}`)?.toJSON();

              return isJsonApi ? serializeForJsonApi(json, schemaKey) : json;
            });
          }
        });

        this.server.get('/organizations/:id/me', (schema, req) =>
          schema.organizationMes.find(`${req.params.id}`)?.toJSON()
        );

        this.server.get('/profiles/:id', (schema, req) => {
          const json = schema.profiles.find(`${req.params.id}`)?.toJSON();

          return {
            ...json,
            report_preference: {
              ...json.report_preference,
              show_pcidss: {
                value: true,
                is_inherited: false,
              },
            },
          };
        });

        await render(
          hbs`<FileDetails::VulnerabilityAnalysisDetails @analysis={{this.analysis}} @showHeader={{true}} />`
        );

        assert.dom('[data-test-analysisDetails-header]').exists();

        assert
          .dom(`[data-test-analysisDetails-regulatory="${modelKey}"]`)
          .doesNotExist();
      }
    );

    // assert pcidss value for below test
    this.assertPcidssValue = async (assert, container, pcidss) => {
      assert
        .dom(
          '[data-test-analysisDetail-regulatoryContent-ValueContainer]',
          container
        )
        .hasText(pcidss.title + ' t:moreDetails:()');

      assert
        .dom(
          '[data-test-analysisDetail-regulatoryContent-valueDescriptionTitle]',
          container
        )
        .doesNotExist();

      await click(
        container.querySelector(
          '[data-test-analysisDetail-regulatoryContent-valueMoreLessBtn]'
        )
      );

      assert
        .dom(
          '[data-test-analysisDetail-regulatoryContent-valueDescriptionTitle]',
          container
        )
        .hasText('t:description:()');

      assert
        .dom(
          '[data-test-analysisDetail-regulatoryContent-valueDescription]',
          container
        )
        .hasText(pcidss.description);

      assert
        .dom(
          '[data-test-analysisDetail-regulatoryContent-valueMoreLessBtn]',
          container
        )
        .hasText('t:lessDetails:()');
    };

    // assert hipaa value for below test
    this.assertHipaaValue = async (assert, container, hipaa) => {
      assert
        .dom(
          '[data-test-analysisDetail-regulatoryContent-ValueContainer]',
          container
        )
        .hasText(`${hipaa.safeguard}: ${hipaa.title} t:moreDetails:()`);

      assert
        .dom(
          '[data-test-analysisDetail-regulatoryContent-valueStandardTitle]',
          container
        )
        .doesNotExist();

      await click(
        container.querySelector(
          '[data-test-analysisDetail-regulatoryContent-valueMoreLessBtn]'
        )
      );

      assert
        .dom(
          '[data-test-analysisDetail-regulatoryContent-valueStandardTitle]',
          container
        )
        .hasText('t:standards:()');

      const standardGroup = container.querySelectorAll(
        '[data-test-analysisDetail-regulatoryContent-valueStandardGroup]'
      );

      standardGroup.forEach((stdEle, i) => {
        const std = hipaa.standards[i];

        assert
          .dom(
            '[data-test-analysisDetail-regulatoryContent-valueStandardLabel]',
            stdEle
          )
          .hasText(`${std.title} (${std.specifications})`);

        assert
          .dom(
            '[data-test-analysisDetail-regulatoryContent-valueStandardDescription]',
            stdEle
          )
          .hasText(std.description);
      });

      assert
        .dom(
          '[data-test-analysisDetail-regulatoryContent-valueMoreLessBtn]',
          container
        )
        .hasText('t:lessDetails:()');
    };

    test.each(
      'test it renders respective regulatory contents with more details',
      [
        [
          'withPcidss',
          'pcidsses',
          'pcidsses',
          'pcidss',
          't:pcidss:()',
          this.assertPcidssValue,
          true,
        ],
        [
          'withHipaa',
          'v2/hipaas',
          'hipaas',
          'hipaa',
          't:hipaa:()',
          this.assertHipaaValue,
        ],
      ],
      async function (
        assert,
        [trait, urlParam, schemaKey, modelKey, label, assertValue, isJsonApi]
      ) {
        const vulnerability = this.store.push(
          this.store.normalize(
            'vulnerability',
            serializeForJsonApi(
              this.server.create('vulnerability').toJSON(),
              'vulnerabilities'
            ).data
          )
        );

        const analysis = this.store.push(
          this.store.normalize(
            'analysis',
            this.server
              .create('analysis', trait, {
                vulnerability: vulnerability.id,
                file: '1',
                status: ENUMS.ANALYSIS_STATUS.COMPLETED,
                computed_risk: ENUMS.RISK.LOW,
              })
              .toJSON()
          )
        );

        // this.file.analyses.push(analysis);

        this.set('analysis', analysis);

        this.server.get('/organizations/:id/me', (schema, req) =>
          schema.organizationMes.find(`${req.params.id}`)?.toJSON()
        );

        this.server.get(`/${urlParam}/:id`, (schema, req) => {
          const json = schema[schemaKey].find(`${req.params.id}`)?.toJSON();

          return isJsonApi ? serializeForJsonApi(json, schemaKey) : json;
        });

        this.server.get('/profiles/:id', (schema, req) => {
          const json = schema.profiles.find(`${req.params.id}`)?.toJSON();

          return {
            ...json,
            report_preference: {
              ...json.report_preference,
              show_pcidss: {
                value: modelKey === 'pcidss',
                is_inherited: false,
              },
              show_hipaa: {
                value: modelKey === 'hipaa',
                is_inherited: false,
              },
            },
          };
        });

        await render(
          hbs`<FileDetails::VulnerabilityAnalysisDetails @analysis={{this.analysis}} @showHeader={{true}} />`
        );

        assert.dom('[data-test-analysisDetails-header]').exists();

        const container = find(
          `[data-test-analysisDetails-regulatory="${modelKey}"]`
        );

        assert.dom(container).exists();

        assert
          .dom('[data-test-analysisDetails-regulatoryLabel]', container)
          .hasText(label);

        const contents = container.querySelectorAll(
          '[data-test-analysisDetail-regulatoryContent-listItem]'
        );

        const regulatorContent = analysis[modelKey].toArray();

        for (let i = 0; i < contents.length; i++) {
          assert
            .dom(
              '[data-test-analysisDetail-regulatoryContent-labelContainer]',
              contents[i]
            )
            .hasText(regulatorContent[i].code);

          await assertValue(assert, contents[i], regulatorContent[i]);
        }
      }
    );
  }
);
