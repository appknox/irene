import cyTranslate from '../support/translations';
import { type MirageFactoryDefProps } from '../support/Mirage';

import LoginActions from '../support/Actions/auth/LoginActions';
import NetworkActions from '../support/Actions/common/NetworkActions';

import IgnoreVulnerabilityActions, {
  RISK_TEXT_MAP,
  type RiskTextKeys,
  type VulnerabilityListResponse,
  type AnalysisItemProps,
} from '../support/Actions/common/IgnoreVulnerabilityActions';

import { API_ROUTES } from '../support/api.routes';
import { APPLICATION_ROUTES } from '../support/application.routes';
import { getVulnerabilityTypeText } from '../support/utils';

// Grouped test Actions
const loginActions = new LoginActions();
const networkActions = new NetworkActions();
const iVActions = new IgnoreVulnerabilityActions();

// User credentials
const username = Cypress.env('TEST_USERNAME');
const password = Cypress.env('TEST_PASSWORD');
const API_HOST = Cypress.env('API_HOST');

const ignoreVulnPrjPackageName = Cypress.env(
  'IGNORE_VULNERABILITY_TEST_PACKAGE_NAME'
);

// Assertion Timeout Overrides
const DEFAULT_ASSERT_OPTS = {
  timeout: 120000,
};

const NETWORK_WAIT_OPTS = {
  timeout: 60000,
};

// fixes cross origin errors
Cypress.on('uncaught:exception', () => {
  // returning false here prevents Cypress from failing the test
  return false;
});

// Test body
describe('Ignore Vulnerability', () => {
  beforeEach(() => {
    // Hide websocket and analyses logs
    networkActions.hideNetworkLogsFor({ ...API_ROUTES.websockets });

    /* TODO: Remove or retain this interception based on whether
     * access to submissions API is restricted or not.
     * -------------------------------------------------
     * Necessary to intercept submission requests that were returning 404
     * This was causing the submission adapters to fail
     */
    networkActions
      .interceptParameterizedRoute<{ subId: string }>({
        route: '/api/submissions/:subId',
        routeHandler: async (req, params) => {
          req.continue((res) => {
            if (res.statusCode === 404) {
              res.send({
                statusCode: 200,
                body: {
                  id: params.subId,
                  status: 7,
                },
              });
            }
          });
        },
      })
      .as('submissionReq');

    // Login or restore session
    loginActions.loginWithCredAndSaveSession({ username, password });

    // Network interceptions
    cy.intercept(API_ROUTES.check.route).as('checkUserRoute');
    cy.intercept(API_ROUTES.userInfo.route).as('userInfoRoute');
    cy.intercept(API_ROUTES.projectList.route).as('orgProjectList');
    cy.intercept(API_ROUTES.submissionList.route).as('submissionList');

    cy.intercept(API_ROUTES.vulnerabilityPreferenceList.route).as(
      'vulnerabilityPreferenceList'
    );

    cy.intercept(API_ROUTES.vulnerabilityList.route).as(
      'vulnerabilityListResponse'
    );
  });

  // Test Scenarios
  const ignoreVulnerabilityScenarios = [
    {
      currentFileOnly: true,
      toPassed: true,
    },
    {
      currentFileOnly: true,
      toPassed: false,
    },
    {
      allFutureAnalysis: true,
      toPassed: false,
      resetForCurrentFileOnly: true,
    },
    {
      allFutureAnalysis: true,
      toPassed: false,
      removeOverride: true,
      checkPrjSettingsOverrideAfterReset: true,
    },
    {
      allFutureAnalysis: true,
      toPassed: false,
      removeOverride: true,
      resetOverrideFromPrjSettings: true,
    },
    {
      allFutureAnalysis: true,
      toPassed: true,
      removeOverride: true,
    },
    {
      allFutureAnalysis: true,
      toPassed: true,
      resetForCurrentFileOnly: true,
      checkOverrideInPrjSettings: true,
    },
  ];

  ignoreVulnerabilityScenarios.forEach((testParams) => {
    const {
      currentFileOnly,
      allFutureAnalysis,
      toPassed,
      resetForCurrentFileOnly,
      removeOverride,
      checkOverrideInPrjSettings,
      checkPrjSettingsOverrideAfterReset,
      resetOverrideFromPrjSettings,
    } = testParams;

    const filesToIgnoreFor = currentFileOnly
      ? '"current file"'
      : '"all future files"';

    const suplementaryRiskDesc = toPassed
      ? 'from Risk --> Passed'
      : 'from Risk --> Risk ';

    const suplementaryResetDesc = resetOverrideFromPrjSettings
      ? 'from Project Settings Page'
      : removeOverride
        ? 'for "Current File + All Future Files"'
        : 'for "Current File Only"';

    it(
      `It ignores vulnerability ${suplementaryRiskDesc} (CRITERIA: ${filesToIgnoreFor}) (RESET: ${suplementaryResetDesc}) `,
      { retries: { runMode: 2 } },
      function () {
        // Used for clean up in afterEach
        cy.wrap(false).as('testCompleted');

        // Visit projects page
        cy.visit(APPLICATION_ROUTES.projects);

        // Necessary API call before showing dashboard elements
        cy.wait('@submissionList', NETWORK_WAIT_OPTS);

        // Save vulnerability list for later assertions
        cy.wait('@vulnerabilityListResponse', NETWORK_WAIT_OPTS)
          .its('response.body')
          .then((vulnerabilities: { data: VulnerabilityListResponse }) => {
            // Filter out deprecated vulnerabilities
            const filteredVulnerabilities = vulnerabilities.data.filter((v) =>
              'is-active' in v.attributes ? v.attributes?.['is-active'] : true
            );

            cy.wrap(filteredVulnerabilities).as('vulnerabilityList');
          });

        // Get project card to click
        cy.wait('@orgProjectList', NETWORK_WAIT_OPTS)
          .its('response.body')
          .then(
            (projectListRes: {
              results: Array<MirageFactoryDefProps['project']>;
            }) => {
              const projectList = projectListRes.results;

              const ignoreVulTestProject = projectList.find((p) =>
                ignoreVulnPrjPackageName.includes(p.package_name)
              );

              if (ignoreVulTestProject) {
                const lastFileId = ignoreVulTestProject.last_file_id;
                const ignoreVulTestPrjFileIntURL = `${API_ROUTES.file.route}/${lastFileId}`;

                cy.wrap(ignoreVulTestProject.id).as('ignoreVulTestProjectId');
                cy.wrap(lastFileId).as('ignoreVulTestProjectLatestFile');

                cy.intercept('GET', ignoreVulTestPrjFileIntURL).as(
                  'ignoreVulTestPrjFileRes'
                );
              }
            }
          );

        // Sanity check for when in project listing page
        cy.findByText(cyTranslate('startNewScan')).should('exist');

        // Wait for project list cards to completely display
        cy.wait(12000);

        // Go to latest file to perform tests in
        cy.get<number>('@ignoreVulTestProjectLatestFile').then((id) =>
          cy
            .findByTestId(`project-overview-${id}`, DEFAULT_ASSERT_OPTS)
            .click({ force: true })
        );

        // Check if in file page
        cy.url().should(
          'contain',
          APPLICATION_ROUTES.file,
          DEFAULT_ASSERT_OPTS
        );

        // Wait for ignore vulnerability file to load
        cy.wait('@ignoreVulTestPrjFileRes', NETWORK_WAIT_OPTS)
          .its('response.body')
          .then((file: MirageFactoryDefProps['file']) => {
            const analyses = file.analyses;

            // File details check
            cy.findByAltText(`${file.name} - logo`).should('exist');
            cy.wrap(file).its('id').should('exist');
            cy.wrap(file).its('name').should('exist');

            // Get first risky analyses
            const riskyAnalysis = analyses.find((a) => {
              return (
                a.overridden_risk === null && // Ignore edited risks
                Number(a.computed_risk) > 0 // Ignore passed analyses
              );
            });

            const riskyAnalysisRisk = riskyAnalysis?.computed_risk;
            const riskyAnalysisPageURL = `/dashboard/file/${file.id}/analysis/${riskyAnalysis?.id}`;

            const riskyAnalysisRiskText =
              RISK_TEXT_MAP[riskyAnalysisRisk as RiskTextKeys];

            // Get possible risks to select
            const possibleRisksToEditTo = Object.keys(RISK_TEXT_MAP).filter(
              (r) => r !== String(riskyAnalysis?.computed_risk) && r !== '0'
            );

            // '0' represents Passed
            cy.wrap(toPassed ? 0 : possibleRisksToEditTo[0]).as('riskToEditTo');

            cy.wrap(riskyAnalysis).as('riskyAnalysis');
            cy.wrap(riskyAnalysisRisk).as('riskyAnalysisRisk');
            cy.wrap(riskyAnalysisPageURL).as('riskyAnalysisPageURL');
            cy.wrap(riskyAnalysis?.id).as('riskyAnalysisId');

            // Get vulnerability info
            cy.get<VulnerabilityListResponse>('@vulnerabilityList').then(
              (vulnerabilities) => {
                const vulnAttributes = vulnerabilities.find(
                  (v) => v.id === riskyAnalysis?.vulnerability
                )?.attributes;

                // Save analysis vulnerability  for later use
                cy.wrap({
                  ...vulnAttributes,
                  id: riskyAnalysis?.vulnerability,
                }).as('riskyAnalysisVuln');

                // Assert vulnerability details in analysis row
                cy.findByTestId(`file-analysis-${riskyAnalysis?.id}`)
                  .as('riskyAnalysisRiskRow')
                  .should('exist')
                  .within(() => {
                    // Check vulnerability details
                    iVActions.assertMultipleTextInfo([
                      riskyAnalysisRiskText,
                      String(vulnAttributes?.name.trim()),
                    ]);

                    // Check that the appropriate scan types exists in row
                    vulnAttributes?.types.forEach((t) =>
                      iVActions.assertMultipleTextInfo([
                        getVulnerabilityTypeText(t),
                      ])
                    );
                  });
              }
            );
          });

        // Go to analysis page
        cy.get('@riskyAnalysisRiskRow').click();

        // Check if in analysis page
        cy.get<string>('@riskyAnalysisPageURL').then((url) =>
          cy.url().should('contain', url)
        );

        cy.getAliases(['@riskToEditTo', '@riskyAnalysisRisk']).then(
          ([r1, r2]) => {
            const riskTextToModifyTo = RISK_TEXT_MAP[r1 as RiskTextKeys];
            const riskyAnalysisRiskText = RISK_TEXT_MAP[r2 as RiskTextKeys];

            // Check if in the correct analysis page
            iVActions
              .getAnalysisVulnerability('@riskyAnalysisVuln')
              .then((v) => {
                cy.findByTestId('analysisDetails-header').within(() => {
                  iVActions.assertMultipleTextInfo([
                    riskyAnalysisRiskText,
                    v.name,
                  ]);
                });

                // Open edit analysis drawer
                iVActions.openEditDrawer('edit analysis button');

                // Check if edit drawer is open
                iVActions.getEditAnalysisDrawer().within(() => {
                  iVActions.assertMultipleTextInfo([
                    riskyAnalysisRiskText,
                    v.name,
                    cyTranslate('editOverrideVulnerability.overrideTo'),
                    cyTranslate('reason'),
                  ]);
                });

                iVActions.doEditAnalysisDetails({
                  toPassed,
                  riskTextToModifyTo,
                  allFutureAnalysis,
                  isInPrjSettingsPage: false,
                });

                iVActions.findBtnByLabelAndClick(cyTranslate('save'));
              });

            // Intercept analysis item response after saving
            iVActions.interceptAnalysisItemRes({
              idAlias: '@riskyAnalysisId',
              intAlias: 'getAnalysisItemRes',
            });

            // Wait for save action to complete
            cy.wait('@getAnalysisItemRes', DEFAULT_ASSERT_OPTS).then((int) => {
              cy.wrap(int?.response?.body).as('updatedRiskyAnalysis');

              // Assert UI after save action
              cy.findByText(
                cyTranslate('fileAnalysisDetails.overrideSuccessMessage')
              ).should('exist');

              cy.findByTestId(
                'overrideEditDrawer-overrideForm-successFromToRiskIcon'
              ).should('exist');

              cy.findByTestId(
                'overrideEditDrawer-overrideForm-successOriginalRisk'
              )
                .should('exist')
                .contains(new RegExp(riskyAnalysisRiskText, 'i'));

              cy.findByTestId(
                'overrideEditDrawer-overrideForm-successOverriddenRisk'
              )
                .should('exist')
                .contains(new RegExp(riskTextToModifyTo, 'i'));
            });

            iVActions.closeEditDrawer();

            cy.wait(4000);

            // Check if ignore vulnerability icon shows in file details page for 'ignored vulnerabilities'
            // And if file "passed" risk sorting is in order
            if (!allFutureAnalysis && toPassed) {
              iVActions.goToFileDetailsFromAnalysis(
                '@ignoreVulTestProjectLatestFile'
              );

              cy.findByTestId(
                'fileChartSeverityLevel-ignoreVulnerabilityIcon',
                DEFAULT_ASSERT_OPTS
              ).should('exist');

              // Find all passed risk and check if first is overridden
              cy.getBySel('file-analysis-computedRisk-0')
                .first()
                .should(
                  'have.attr',
                  'data-test-file-analysis-isOverriddenAsPassed',
                  'true'
                );

              // Go back to analysis details page
              cy.get('@riskyAnalysisRiskRow').click();
            }

            // Check if override is in project analysis settings page
            if (allFutureAnalysis && checkOverrideInPrjSettings) {
              iVActions.goToFileDetailsFromAnalysis(
                '@ignoreVulTestProjectLatestFile'
              );

              iVActions.goToPrjAnalysisSettings(
                '@ignoreVulTestProjectId',
                ignoreVulnPrjPackageName
              );

              cy.wait('@vulnerabilityPreferenceList', DEFAULT_ASSERT_OPTS);

              // Do analysis edit details check in edit drawer
              iVActions
                .getAnalysisVulnerability('@riskyAnalysisVuln')
                .then((v) => {
                  iVActions.getVulnPrefItemRow(v.id).within(() => {
                    iVActions.assertMultipleTextInfo([
                      v.name,
                      riskTextToModifyTo,
                    ]);

                    iVActions.openEditDrawer('vulnerability preference action');
                  });

                  // Assert analysis details in drawer
                  iVActions.assertEditedAnalysisInfo('@updatedRiskyAnalysis', {
                    riskTextToModifyTo,
                    riskyAnalysisRiskText,
                  });

                  iVActions.closeEditDrawer();
                });

              iVActions.doGoToAnalysisDetailsPage(
                '@ignoreVulTestProjectLatestFile',
                '@riskyAnalysisId'
              );
            }

            // Open edit analysis drawer
            iVActions.openEditDrawer('edit analysis button');

            // Check if edit drawer is open
            iVActions.getEditAnalysisDrawer().within(() => {
              // Assert analysis details in drawer
              iVActions.assertEditedAnalysisInfo('@updatedRiskyAnalysis', {
                riskTextToModifyTo,
                riskyAnalysisRiskText,
              });

              // Only do override from analysis details page if not coerced to
              // Necessary for testing override from project settings page
              if (!resetOverrideFromPrjSettings) {
                iVActions.doResetAnalysis({
                  resetForCurrentFileOnly,
                  allFutureAnalysis,
                  removeOverride,
                });
              }

              iVActions.closeEditDrawer();
            });

            // Perform check to ensure reset is reflected in project settings also
            if (checkPrjSettingsOverrideAfterReset) {
              iVActions.goToFileDetailsFromAnalysis(
                '@ignoreVulTestProjectLatestFile'
              );

              iVActions.goToPrjAnalysisSettings(
                '@ignoreVulTestProjectId',
                ignoreVulnPrjPackageName
              );

              iVActions
                .getAnalysisVulnerability('@riskyAnalysisVuln')
                .then((v) => {
                  iVActions.getVulnPrefItemRow(v.id).within(() => {
                    cy.findByText(v.name).should('exist');
                    cy.findByText(riskTextToModifyTo).should('not.exist');
                    cy.findByText(riskyAnalysisRiskText).should('not.exist');

                    iVActions.openEditDrawer('vulnerability preference action');
                  });

                  // Edit reason should be empty after reset
                  iVActions.getEditAnalysisDrawer().within(() => {
                    cy.get('@editOverrideVulnerabilityReason')
                      .should('exist')
                      .should('not.have.value');
                  });
                });
            }

            // Perform "All future analysis" reset from project settings page
            if (allFutureAnalysis && resetOverrideFromPrjSettings) {
              iVActions.goToFileDetailsFromAnalysis(
                '@ignoreVulTestProjectLatestFile'
              );

              iVActions.goToPrjAnalysisSettings(
                '@ignoreVulTestProjectId',
                ignoreVulnPrjPackageName
              );

              cy.wait('@vulnerabilityPreferenceList', DEFAULT_ASSERT_OPTS);

              iVActions
                .getAnalysisVulnerability('@riskyAnalysisVuln')
                .then((v) => {
                  iVActions.getVulnPrefItemRow(v.id).within(() =>
                    // Open edit drawer
                    iVActions.openEditDrawer('vulnerability preference action')
                  );

                  // Assert default unedited state in edit drawer
                  iVActions.getEditAnalysisDrawer().within(() => {
                    iVActions.doResetAnalysis({
                      resetForCurrentFileOnly,
                      allFutureAnalysis,
                      removeOverride,
                      isInPrjSettingsPage: true,
                    });

                    iVActions.closeEditDrawer();
                  });

                  // Analysis row should be reset
                  iVActions.getVulnPrefItemRow(v.id).within(() => {
                    cy.findByText(v.name).should('exist');
                    cy.findByText(riskTextToModifyTo).should('not.exist');
                  });

                  iVActions.interceptAnalysisItemRes({
                    idAlias: '@riskyAnalysisId',
                    intAlias: 'updatedAnalysisItem',
                  });

                  iVActions.doGoToAnalysisDetailsPage(
                    '@ignoreVulTestProjectLatestFile',
                    '@riskyAnalysisId'
                  );

                  // Open edit analysis drawer
                  iVActions.openEditDrawer('edit analysis button');

                  // Get updated info of reset analysis
                  cy.wait('@updatedAnalysisItem')
                    .its('response.body')
                    .then((resetAnalysisItem) => {
                      cy.wrap(resetAnalysisItem).as('resetAnalysisItem');
                    });

                  // Assert that updated info is being shown correctly
                  iVActions.getEditAnalysisDrawer().within(() => {
                    // Edited props should still exist
                    iVActions.assertEditedAnalysisInfo('@resetAnalysisItem', {
                      riskTextToModifyTo,
                      riskyAnalysisRiskText,
                    });

                    // Reset from project settings alters the "All future analyses" to "Current file only"
                    iVActions.doResetAnalysis({
                      resetForCurrentFileOnly,
                      currentFileOnly: true,
                      removeOverride: false,
                    });

                    iVActions.closeEditDrawer();
                  });
                });
            }

            cy.wrap(true).as('testCompleted');
          }
        );
      }
    );
  });

  afterEach(() => {
    // Reset edited analysis if test fails
    cy.get<boolean>('@testCompleted').then((testCompleted) => {
      if (!testCompleted) {
        cy.getAliases([
          '@ignoreVulTestProjectLatestFile',
          '@riskyAnalysis',
        ]).then(([fileId, analysis]) =>
          cy.makeAuthenticatedAPIRequest({
            method: 'DELETE',
            url: `${API_HOST}/api/files/${fileId}/vulnerability_preferences/${(analysis as AnalysisItemProps).vulnerability}/risk`,
            body: { all: true },
          })
        );
      }
    });
  });
});
