import { action } from '@ember/object';
import { inject as service } from '@ember/service';
import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';
import { task } from 'ember-concurrency';
import IntlService from 'ember-intl/services/intl';

import ENUMS from 'irene/enums';
import ENV from 'irene/config/environment';
import triggerAnalytics from 'irene/utils/trigger-analytics';
import AnalysisModel from 'irene/models/analysis';

export interface FileDetailsVulnerabilityAnalysisDetailsEditAnalysisFormSignature {
  Args: {
    analysis: AnalysisModel;
    isEditingOverriddenRisk?: boolean;
    handleEditOverriddenRiskCancel?: () => void;
  };
}

export default class FileDetailsVulnerabilityAnalysisDetailsEditAnalysisFormComponent extends Component<FileDetailsVulnerabilityAnalysisDetailsEditAnalysisFormSignature> {
  @service declare intl: IntlService;
  @service declare ajax: any;
  @service('notifications') declare notify: NotificationService;

  @tracked markedRisk = this.defaultMarkedRisk;
  @tracked isMarkingAnalysis = false;
  @tracked markAllAnalyses = this.overrideRiskForOptions[0];

  get analysis() {
    return this.args.analysis || null;
  }

  get vulnerability() {
    return this.analysis.vulnerability || null;
  }

  get defaultMarkedRisk() {
    return this.filteredRisks[0];
  }

  get filteredRisks() {
    const risks = this.risks;
    const analysisRisk = this.analysis.risk;

    return risks.filter((risk) => analysisRisk !== risk.value);
  }

  get risks() {
    const risks = ENUMS.RISK.CHOICES;
    const riskFilter = [ENUMS.RISK.NONE, ENUMS.RISK.UNKNOWN];

    return risks.filter((risk) => !riskFilter.includes(risk.value as number));
  }

  get overrideRiskForOptions() {
    return [
      { label: this.intl.t('currentFileOnly'), value: 'false' },
      { label: this.intl.t('allFutureAnalyses'), value: 'true' },
    ];
  }

  @action markAnalysis() {
    this.markAnalysisTask.perform();
  }

  @action selectMarkedAnalyis(markedRisk: typeof this.defaultMarkedRisk) {
    this.markedRisk = markedRisk;
  }

  @action selectMarkedAnalyisType(
    markAllAnalyses: typeof this.markAllAnalyses
  ) {
    this.markAllAnalyses = markAllAnalyses;
  }

  @action handleEditOverriddenRiskCancel() {
    this.args.handleEditOverriddenRiskCancel?.();
  }

  _editAnalysisURL(type: string) {
    const fileId = this.analysis.file.get?.('id');
    const vulnerabilityId = this.vulnerability.get?.('id');

    const url = [
      ENV.endpoints['files'],
      fileId,
      ENV.endpoints['vulnerabilityPreferences'],
      vulnerabilityId,
      type,
    ].join('/');

    return url;
  }

  markAnalysisTask = task(async () => {
    try {
      const comment = this.analysis.overriddenRiskComment;

      if (!this.markedRisk?.value || !comment) {
        this.notify.error(this.intl.t('riskAndCommentRequired'));

        return;
      }

      const url = this._editAnalysisURL('risk');

      const data = {
        risk: this.markedRisk?.value,
        comment: comment,
        all: this.markAllAnalyses?.value === 'true',
      };

      this.isMarkingAnalysis = true;

      await this.ajax.put(url, {
        data,
      });

      triggerAnalytics(
        'feature',
        ENV.csb['editAnalysis'] as CsbAnalyticsFeatureData
      );

      if (!this.isDestroyed) {
        this.notify.success(this.intl.t('successfullyOverridden'));
        this.isMarkingAnalysis = false;

        this.handleEditOverriddenRiskCancel();

        this.analysis.overriddenRisk = this.markedRisk.value as number;
        this.analysis.computedRisk = this.markedRisk.value as number;
      }
    } catch (error) {
      this.notify.error((error as AdapterError).payload.message);
      this.isMarkingAnalysis = false;
    }
  });
}

declare module '@glint/environment-ember-loose/registry' {
  export default interface Registry {
    'FileDetails::VulnerabilityAnalysisDetails::EditAnalysisForm': typeof FileDetailsVulnerabilityAnalysisDetailsEditAnalysisFormComponent;
  }
}
