import { action } from '@ember/object';
import { service } from '@ember/service';
import Component from '@glimmer/component';
import type { EmberTableSort } from 'ember-table';
import type RouterService from '@ember/routing/router-service';
import type IntlService from 'ember-intl/services/intl';

import ENUMS from 'irene/enums';
import type FileModel from 'irene/models/file';
import type AnalysisOverviewModel from 'irene/models/analysis-overview';

interface columnType {
  name: string;
  component?: string;
  valuePath?: string;
  width?: number;
  textAlign?: string;
  isSortable?: boolean;
}

export interface FileDetailsVulnerabilityAnalysisTableSignature {
  Args: {
    file: FileModel;
    sorts: EmberTableSort[];
    filterVulnerabilityType: string | number;
    updateAnalysesSorts: (sorts: EmberTableSort[]) => void;
    columns?: columnType[];
    fileAnalyses: AnalysisOverviewModel[];
    loadingFileAnalyses: boolean;
  };
}

export default class FileDetailsVulnerabilityAnalysisTableComponent extends Component<FileDetailsVulnerabilityAnalysisTableSignature> {
  @service declare intl: IntlService;
  @service declare router: RouterService;

  get columns() {
    const defaultColumns: columnType[] = [
      {
        name: this.intl.t('impact'),
        valuePath: 'computedRisk',
        component: 'file-details/vulnerability-analysis/impact',
        width: 70,
        textAlign: 'center',
      },
      {
        name: this.intl.t('title'),
        width: 200,
        valuePath: 'vulnerability.name',
        isSortable: false,
      },
      {
        name: this.intl.t('typeOfScan'),
        component: 'file-details/type-of-scan',
        textAlign: 'right',
      },
    ];

    return this.args.columns ?? defaultColumns;
  }

  get file() {
    return this.args.file;
  }

  get analyses() {
    return this.args.fileAnalyses;
  }

  get finalSortedAnalyses() {
    const filteredAnalyess = this.filterAnalysesByVulnerabilityType(
      this.args.filterVulnerabilityType
    );

    return filteredAnalyess.sort(this.sortAnalysesFn);
  }

  get isFinalAnalysesEmpty() {
    return this.finalSortedAnalyses.length === 0;
  }

  @action
  sortAnalysesFn(a: AnalysisOverviewModel, b: AnalysisOverviewModel) {
    const isAscending = this.args.sorts[0]?.isAscending ?? false; // default is desc

    if (a.isOverriddenAsPassed && b.isRiskPassedBySystem) {
      return isAscending ? 1 : -1;
    }

    if (b.isOverriddenAsPassed && a.isRiskPassedBySystem) {
      return isAscending ? -1 : 1;
    }

    return isAscending
      ? a.computedRisk - b.computedRisk
      : b.computedRisk - a.computedRisk;
  }

  @action
  updateAnalysesSorts(sorts: EmberTableSort[]) {
    if (this.args.sorts[0] && !sorts.length) {
      this.args.updateAnalysesSorts([
        {
          valuePath: this.args.sorts[0].valuePath,
          isAscending: !this.args.sorts[0].isAscending,
        },
      ]);

      return;
    }

    this.args.updateAnalysesSorts(sorts);
  }

  @action
  handleAnalysisClick({
    rowValue,
    event,
  }: {
    rowValue: AnalysisOverviewModel;
    event: MouseEvent;
  }) {
    // temp fix
    if (event.ctrlKey || event.metaKey) {
      const url = this.router.urlFor(
        'authenticated.dashboard.file.analysis',
        this.file.id,
        rowValue.id
      );

      window.open(url, '_blank');
    } else {
      this.router.transitionTo(
        'authenticated.dashboard.file.analysis',
        this.file.id,
        rowValue.id
      );
    }
  }

  filterAnalysesByVulnerabilityType(type: string | number) {
    const vulnerabilityType = parseInt(String(type));

    if (vulnerabilityType === ENUMS.VULNERABILITY_TYPE.UNKNOWN) {
      return this.analyses.slice();
    }

    const filteredAnalysis = this.analyses?.filter((a) =>
      a.hasType(vulnerabilityType)
    );

    return filteredAnalysis;
  }
}

declare module '@glint/environment-ember-loose/registry' {
  export default interface Registry {
    'FileDetails::VulnerabilityAnalysis::Table': typeof FileDetailsVulnerabilityAnalysisTableComponent;
  }
}
