/* eslint-disable ember/no-computed-properties-in-native-classes */
import { action, computed } from '@ember/object';
import RouterService from '@ember/routing/router-service';
import { inject as service } from '@ember/service';
import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';
import { task } from 'ember-concurrency';
import IntlService from 'ember-intl/services/intl';
import { EmberTableSort } from 'ember-table';

import ENUMS from 'irene/enums';
import AnalysisModel from 'irene/models/analysis';
import FileModel from 'irene/models/file';
import styles from './index.scss';

export interface FileDetailsVulnerabilityAnalysisSignature {
  Args: {
    file: FileModel;
  };
}

const DEFAULT_ANALYSES_SORTS = [
  { isAscending: false, valuePath: 'computedRisk' },
];

export default class FileDetailsVulnerabilityAnalysisComponent extends Component<FileDetailsVulnerabilityAnalysisSignature> {
  @service declare ajax: any;
  @service declare intl: IntlService;
  @service declare router: RouterService;

  @tracked isSecurityEnabled = false;
  @tracked analysesSorts: EmberTableSort[] = DEFAULT_ANALYSES_SORTS;
  @tracked analyses: AnalysisModel[] = [];

  @tracked vulnerabilityType: string | number =
    ENUMS.VULNERABILITY_TYPE.UNKNOWN;

  constructor(
    owner: unknown,
    args: FileDetailsVulnerabilityAnalysisSignature['Args']
  ) {
    super(owner, args);

    this.securityEnabled.perform();
    this.analyses = this.args.file.analyses.toArray();

    // Register an event to update analyses when the files route changes
    this.router.on('routeDidChange', this.updateAnalyses);
  }

  get classes() {
    return {
      vulnerabilityTypeFilterSelectTrigger:
        styles['vulnerability-type-filter-select-trigger'],
    };
  }

  get columns() {
    return [
      {
        name: this.intl.t('impact'),
        valuePath: 'computedRisk',
        component: 'risk-tag',
        width: 65,
        textAlign: 'center',
      },
      {
        name: this.intl.t('title'),
        width: 200,
        valuePath: 'vulnerability.name',
        isSortable: false,
      },
      {
        name: this.intl.t('typeOfScan'),
        component: 'file-details/type-of-scan',
        textAlign: 'right',
      },
    ];
  }

  get file() {
    return this.args.file;
  }

  // computed is required to track 'computedRisk' changes
  @computed('analyses.@each.computedRisk', 'vulnerabilityType')
  get finalUnsortedAnalyses() {
    return this.filterAnalysesByVulnerabilityType(this.vulnerabilityType);
  }

  get isManualScanDisabled() {
    return !this.file.project?.get('isManualScanAvailable');
  }

  get vulnerabilityTypes() {
    const manualType = ENUMS.VULNERABILITY_TYPE.MANUAL;
    const types = ENUMS.VULNERABILITY_TYPE.CHOICES.slice(0, -1);

    const options = [
      ENUMS.VULNERABILITY_TYPE.UNKNOWN,
      ...types.map(({ value }) => value),
    ] as number[];

    return this.isManualScanDisabled
      ? options.filter((type) => type !== manualType)
      : options;
  }

  @action
  filterVulnerabilityType(vulnerabilityType: number) {
    // reset sorting
    this.analysesSorts = DEFAULT_ANALYSES_SORTS;

    this.vulnerabilityType = vulnerabilityType;
  }

  @action
  updateAnalysesSorts(sorts: EmberTableSort[]) {
    if (this.analysesSorts[0] && !sorts.length) {
      this.analysesSorts = [
        {
          valuePath: this.analysesSorts[0].valuePath,
          isAscending: !this.analysesSorts[0].isAscending,
        },
      ];

      return;
    }

    this.analysesSorts = sorts;
  }

  @action
  handleAnalysisClick({ rowValue }: { rowValue: AnalysisModel }) {
    this.router.transitionTo(
      'authenticated.dashboard.file.analysis',
      this.file.id,
      rowValue.id
    );
  }

  @action updateAnalyses() {
    this.analyses = this.args.file.analyses.toArray();
  }

  willDestroy() {
    super.willDestroy();
    this.router.off('routeDidChange', this.updateAnalyses);
  }

  securityEnabled = task(async () => {
    try {
      await this.ajax.request('projects', { namespace: 'api/hudson-api' });

      if (!this.isDestroyed) {
        this.isSecurityEnabled = true;
      }
    } catch (error) {
      if (!this.isDestroyed) {
        this.isSecurityEnabled = false;
      }
    }
  });

  filterAnalysesByVulnerabilityType(type: string | number) {
    const vulnerabilityType = parseInt(String(type));

    if (vulnerabilityType === ENUMS.VULNERABILITY_TYPE.UNKNOWN) {
      return this.analyses;
    }

    const filteredAnalysis = this.analyses?.filter((a) =>
      a.hasType(vulnerabilityType)
    );

    return filteredAnalysis;
  }
}

declare module '@glint/environment-ember-loose/registry' {
  export default interface Registry {
    'FileDetails::VulnerabilityAnalysis': typeof FileDetailsVulnerabilityAnalysisComponent;
  }
}
